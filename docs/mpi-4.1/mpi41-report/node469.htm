<!DOCTYPE html>
<html lang=en>
<head>
<!-- This file was generated by tohtml from chap-binding/binding-2-rendered -->
<!-- with the command
tohtml -default -numbers -dosnl -htables -quietlatex -allgif -endpage mpi4-forum-tail.htm -Wnoredef --mpidoc --latexpgm pdflatex --indexfile mpi41-report-html.idx -basedef mpi4defs.txt -o mpi41-report.tex mpi-report.tex 
-->
<title>Interface Specifications, Procedure Names, and the Profiling Interface</title>
</head>
<body style="background-color:#FFFFFF">
<hr><h2><span id="Node469">20.1.5. Interface Specifications, Procedure Names, and the Profiling Interface</span></h2>
<a href="node468.htm#Node468"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node464.htm#Node464"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node470.htm#Node470"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node464.htm#Node464"> Support for Fortran</a>
<b>Next: </b><a href="node470.htm#Node470"> <font face="sans-serif"> MPI</font> for Different Fortran Standard Versions</a>
<b>Previous: </b><a href="node468.htm#Node468"> Fortran Support Through the <tt>mpif.h</tt> Include File</a>
<p>
  
<P> 
The Fortran interface specification of each <font face="sans-serif"> MPI</font> routine  
specifies the routine name that must be called by the application program,  
and the names and types of the dummy arguments together with  
additional attributes.  
The Fortran standard allows  
a given Fortran interface to be implemented  
with several methods, e.g., within or outside of a module,  
with or without <tt> BIND(C)</tt>, or the buffers with or without  
Fortran 2018 (as successor of Fortran 2008 with TS 29113).  
Such implementation decisions imply different binary interfaces  
and different specific procedure names.  
The requirements for  
several implementation schemes together with the  
rules for the specific procedure names and  
its implications for the profiling interface are specified  
within this section, but not the implementation details.  
<P> 
 
<br> 
<em> Rationale.</em>  
<P> 
When this section was originally introduced in <font face="sans-serif"> MPI-3.0</font>,  
the major goals for the three  
Fortran support methods were:  
<ul> 
   
<li>Portable implementation of the wrappers  
  from the <font face="sans-serif"> MPI</font> Fortran interfaces to the <font face="sans-serif"> MPI</font> routines in C.  
   
<li>Binary backward compatible implementation path when switching  
  <font face="sans-serif"> MPI_SUBARRAYS_SUPPORTED</font> from <tt>.FALSE.</tt> to <tt>.TRUE.</tt>.  
   
<li>The Fortran <font face="sans-serif"> PMPI</font> interface need not be backward compatible,  
  but a method must be included that a tools layer can use to examine the  
  <font face="sans-serif"> MPI</font> library about the specific procedure names and interfaces used.  
   
<li>No performance drawbacks.  
   
<li>Consistency between all three Fortran support methods.  
   
<li>Consistent with Fortran 2018.  
</ul> 
<br> 
The design expected that all dummy arguments in the  
<font face="sans-serif"> MPI</font> Fortran interfaces are interoperable with C according  
to Fortran 2018.  
This expectation was not fulfilled.  
The <tt> LOGICAL</tt> arguments are not interoperable with C,  
mainly because the internal representations for <tt>.FALSE.</tt> and  
<tt>.TRUE.</tt> are compiler dependent.  
The provided interface was mainly based on <tt> BIND(C)</tt> interfaces  
and therefore inconsistent with Fortran.  
To be consistent with Fortran, the <tt> BIND(C)</tt> had to be  
removed from the callback procedure interfaces and the predefined callbacks,  
e.g., <font face="sans-serif"> MPI_COMM_DUP_FN</font>.  
Non-<tt> BIND(C)</tt> procedures are also not interoperable with C,  
and therefore the <tt> BIND(C)</tt> had to be removed from all routines  
with <tt> PROCEDURE</tt> arguments,  
e.g., from <font face="sans-serif"> MPI_OP_CREATE</font>.  
<P> 
Therefore, this section was rewritten as an erratum to <font face="sans-serif"> MPI-3.0</font>.  
 (<em> End of rationale.</em>) <br> 
A Fortran call to an <font face="sans-serif"> MPI</font> routine shall result in a call to a procedure  
with one of the specific procedure names and calling conventions, as described in  
Table <a href="node469.htm#Table28">28</a>.  
Case is not significant in the names.  
<P> 
<br> 
<b>Table 28: </b><span id="Table28"></span><P> 
Specific Fortran procedure names and related calling conventions.  
<font face="sans-serif"> MPI_ISEND</font> is used as an example.  
For routines without choice buffers, only 1A and 2A apply.  
  
<div style="text-align:center">  
<TABLE><TR><TD ALIGN="LEFT">  
<b> No.</b></TD><TD ALIGN="LEFT"> <b> Specific pro-</b></TD><TD ALIGN="CENTER"> <b> Calling convention</b> </TD></TR> 
<TR><TD ALIGN="LEFT">  
</TD><TD ALIGN="LEFT"> <b> cedure name</b></TD><TD ALIGN="CENTER">                    </TD></TR> 
<TR><TD ALIGN="LEFT">  
  
1A</TD><TD ALIGN="LEFT"> <font face="sans-serif"> MPI_Isend_f08</font>  
</TD><TD ALIGN="CENTER"> Fortran interface and arguments, as in Annex <a href="node553.htm#Node553">Fortran 2008 Bindings with the <tt>mpi_f08</tt> Module</a>, except that  
                              in routines with a choice buffer dummy argument, this  
                              dummy argument is implemented with nonstandard  
                              extensions like <tt>!$PRAGMA IGNORE_TKR</tt>, which  
                              provides a call-by-reference argument without type, kind,  
                              and dimension checking.  
</TD></TR> 
<TR><TD ALIGN="LEFT">  
1B</TD><TD ALIGN="LEFT"> <font face="sans-serif"> MPI_Isend_f08ts</font>  
</TD><TD ALIGN="CENTER"> Fortran interface and arguments, as in Annex <a href="node553.htm#Node553">Fortran 2008 Bindings with the <tt>mpi_f08</tt> Module</a>,  
                              but only for routines with one or more choice buffer dummy arguments;  
                              these dummy arguments are implemented  
                              with <tt>TYPE(*), DIMENSION(..)</tt>.  
</TD></TR> 
<TR><TD ALIGN="LEFT">  
2A</TD><TD ALIGN="LEFT"> <font face="sans-serif"> MPI_ISEND</font>  
</TD><TD ALIGN="CENTER"> Fortran interface and arguments, as in Annex <a href="node569.htm#Node569">Fortran Bindings with <tt>mpif.h</tt> or the <tt>mpi</tt> Module</a>, except that  
                              in routines with a choice buffer dummy argument, this  
                              dummy argument is implemented with nonstandard  
                              extensions like <tt>!$PRAGMA IGNORE_TKR</tt>, which  
                              provides a call-by-reference argument without type, kind,  
                              and dimension checking.  
</TD></TR> 
<TR><TD ALIGN="LEFT">  
2B</TD><TD ALIGN="LEFT"> <font face="sans-serif"> MPI_ISEND_FTS</font>  
</TD><TD ALIGN="CENTER"> Fortran interface and arguments, as in Annex <a href="node569.htm#Node569">Fortran Bindings with <tt>mpif.h</tt> or the <tt>mpi</tt> Module</a>,  
                              but only for routines with one or more choice buffer dummy arguments;  
                              these dummy arguments are implemented  
                              with <tt>TYPE(*), DIMENSION(..)</tt>.  
                              In the (deprecated) <tt>mpif.h</tt> only, the postfix ``<font face="sans-serif"> _FTS</font>'' for   
                              <font face="sans-serif"> MPI_NEIGHBOR_ALLGATHERV_INIT</font>, <font face="sans-serif"> MPI_NEIGHBOR_ALLTOALLV_INIT</font>,  
                              and <font face="sans-serif"> MPI_NEIGHBOR_ALLTOALLW_INIT</font> is shortened to ``<font face="sans-serif"> _F</font>''.  
</TD></TR> 
<TR><TD ALIGN="LEFT">  
  
</TD></TR></TABLE> 
</div>  
Note that for the deprecated routines in  
Section <a href="node444.htm#Node444">Deprecated since <font face="sans-serif"> MPI-2.0</font></a>,  
which are reported only in  
Annex <a href="node569.htm#Node569">Fortran Bindings with <tt>mpif.h</tt> or the <tt>mpi</tt> Module</a>,  
scheme 2A is utilized in the <tt>mpi</tt> module and (deprecated) <tt>mpif.h</tt>,  
and also in the <tt>mpi_f08</tt> module.  
<P> 
To set <font face="sans-serif"> MPI_SUBARRAYS_SUPPORTED</font> to <tt>.TRUE.</tt>  
within a Fortran support method, it is required that  
all nonblocking and split-collective routines with buffer arguments  
are implemented according to 1B and 2B, i.e.,  
with <font face="sans-serif"> MPI_Xxxx_f08ts</font> in the <tt>mpi_f08</tt> module,  
and with <font face="sans-serif"> MPI_XXXX_FTS</font> in the <tt>mpi</tt> module  
and the (deprecated) <tt>mpif.h</tt> include file.  
<P> 
The <tt>mpi</tt> and <tt>mpi_f08</tt> modules and the (deprecated) <tt>mpif.h</tt>  
include file  
will each correspond to exactly one implementation scheme from  
Table <a href="node469.htm#Table28">28</a>.  
However, the <font face="sans-serif"> MPI</font> library may contain multiple implementation schemes from  
Table <a href="node469.htm#Table28">28</a>.  
 
<br> 
<em> Advice  
        to implementors.</em>  
<P> 
This may be desirable for backwards binary compatibility  
in the scope of a single <font face="sans-serif"> MPI</font> implementation, for example.  
 (<em> End of advice to implementors.</em>) <br> 
 
<br> 
<em> Rationale.</em>  
<P> 
After a compiler provides the facilities  
<tt>TYPE(*), DIMENSION(..)</tt> from Fortran 2018,  
it is possible to change the bindings within a Fortran support method  
to support subarrays  
without recompiling the complete application  
provided that the previous interfaces  
with their specific procedure names are still included in the library.  
Of course, only recompiled routines can benefit from the  
added facilities.  
There is no binary compatibility conflict  
because each interface uses its own  
specific procedure names and  
all interfaces use the same constants  
(except the value of <font face="sans-serif"> MPI_SUBARRAYS_SUPPORTED</font> and <font face="sans-serif"> MPI_ASYNC_PROTECTS_NONBLOCKING</font>)  
and type definitions.  
After a compiler also ensures that buffer arguments of nonblocking <font face="sans-serif"> MPI</font> operations  
can be protected through the <tt> ASYNCHRONOUS</tt> attribute,  
and the procedure declarations in the <tt>mpi_f08</tt> and <tt>mpi</tt> module  
and the (deprecated) <tt>mpif.h</tt> include file declare choice buffers  
with the <tt> ASYNCHRONOUS</tt> attribute, then  
the value of <font face="sans-serif"> MPI_ASYNC_PROTECTS_NONBLOCKING</font> can be switched to <tt>.TRUE.</tt>  
in the module definition and include file.  
 (<em> End of rationale.</em>) <br> 
 
<br> 
<em> Advice to users.</em>  
<P> 
Partial recompilation of user applications when upgrading <font face="sans-serif"> MPI</font> implementations  
is a highly complex and subtle topic.  
Users are strongly advised to consult their <font face="sans-serif"> MPI</font> implementation's documentation  
to see exactly what is---and what is not---supported.  
 (<em> End of advice to users.</em>) <br> 
Within the <tt>mpi_f08</tt> and <tt>mpi</tt> modules and (deprecated) <tt>mpif.h</tt> include file,  
for all <font face="sans-serif"> MPI</font> procedures, a second  
procedure with the same calling conventions shall be  
supplied, except that the name is modified by prefixing with the  
letter ``P'', e.g., <font face="sans-serif"> PMPI_Isend</font>.  
The specific procedure names  
for these <font face="sans-serif"> PMPI_</font><font face="sans-serif"> Xxxx</font> procedures must be different from the  
specific procedure names for the <font face="sans-serif"> MPI_Xxxx</font> procedures  
and are not specified by this standard.  
<P> 
A user-written or middleware profiling routine  
should provide the same specific Fortran  
procedure names and calling conventions, and therefore  
can interpose itself as the <font face="sans-serif"> MPI</font> library routine.  
The profiling routine can internally call the matching <font face="sans-serif"> PMPI</font>  
routine with any of its existing bindings,  
except for routines that have callback routine dummy arguments,  
choice buffer arguments, or that are attribute caching routines  
(<font face="sans-serif"> MPI_{COMM<i>|</i>WIN<i>|</i>TYPE}_{SET<i>|</i>GET}_ATTR</font>).  
In this case, the profiling software  
should  
invoke the corresponding <font face="sans-serif"> PMPI</font> routine using  
the same Fortran  
support method as used in the calling application program,  
because the C, <tt>mpi_f08</tt> and <tt>mpi</tt> callback  
prototypes are different or the meaning of the choice buffer  
or <font face="sans-serif"> attribute_val</font> arguments are different.  
<P> 
 
<br> 
<em> Advice to users.</em>  
<P> 
Although for each support method and <font face="sans-serif"> MPI</font> routine  
(e.g., <font face="sans-serif"> MPI_ISEND</font> in <tt>mpi_f08</tt>),  
multiple routines may need to be provided to intercept the  
specific procedures in the <font face="sans-serif"> MPI</font> library  
(e.g., <font face="sans-serif"> MPI_Isend_f08</font> and <font face="sans-serif"> MPI_Isend_f08ts</font>),  
each profiling routine itself uses only one support method  
(e.g., <tt>mpi_f08</tt>)  
and calls the real <font face="sans-serif"> MPI</font> routine through the one  
<font face="sans-serif"> PMPI</font> routine defined in this support method  
(i.e., <font face="sans-serif"> PMPI_Isend</font> in this example).  
 (<em> End of advice to users.</em>) <br> 
 
<br> 
<em> Advice  
        to implementors.</em>  
<P> 
If all of the following conditions are fulfilled:  
<ul> 
 
<li>the handles in the <tt>mpi_f08</tt> module occupy one Fortran  
   numerical storage unit (same as an <tt> INTEGER</tt> handle),  
 
<li>the internal argument passing mechanism used to pass an actual <font face="sans-serif"> ierror</font>  
   argument to a nonoptional <font face="sans-serif"> ierror</font> dummy argument is binary  
   compatible to passing an actual <font face="sans-serif"> ierror</font> argument to an <font face="sans-serif"> ierror</font>  
   dummy argument that is declared as <tt> OPTIONAL</tt>,  
 
<li>the internal argument passing mechanism for <tt> ASYNCHRONOUS</tt> and  
   non-<tt> ASYNCHRONOUS</tt> arguments is the same,  
 
<li>the internal routine call mechanism is the same for  
   the Fortran and the C compilers for which the <font face="sans-serif"> MPI</font> library is compiled, and  
 
<li>the compiler does not provide the appropriate features from Fortran 2018,  
</ul> 
<br> 
then the implementor may use the same  
internal routine implementations for all Fortran support  
methods but with several different specific procedure names.  
If the accompanying Fortran compiler supports Fortran 2018 or at least Fortran 2008 with TS 29113,  
then the new routines are needed only for routines with  
choice buffer arguments.  
 (<em> End of advice to implementors.</em>) <br> 
 
<br> 
<em> Advice  
        to implementors.</em>  
<P> 
In the (deprecated) Fortran support method <tt>mpif.h</tt>,  
compile-time argument checking  
can be also implemented for all routines.  
For <tt>mpif.h</tt>, the argument names are not specified through the <font face="sans-serif"> MPI</font> standard,  
i.e., only positional argument lists are defined, and not key-word based lists.  
Due to the rule that <tt>mpif.h</tt>  
must be valid for fixed and free source form,  
the subroutine declaration is restricted to one line with 72 characters.  
To keep the argument lists short, each argument name can be shortened  
to a minimum of one character. With this, the three longest subroutine  
declaration statements are  
<br> 
<pre><tt>     SUBROUTINE PMPI_DIST_GRAPH_CREATE_ADJACENT(a,b,c,d,e,f,g,h,i,j,k) 
     SUBROUTINE PMPI_NEIGHBOR_ALLTOALLW_INIT(a,b,c,d,e,f,g,h,i,j,k,l) 
     SUBROUTINE PMPI_NEIGHBOR_ALLTOALLV_INIT(a,b,c,d,e,f,g,h,i,j,k,l) 
</tt></pre> 
with 71 and 70 characters each.  
With buffers implemented with Fortran 2018 (or TS 29113),  
the specific procedure names have an  
additional postfix. Some of the longest of such interface definitions are  
<br> 
<pre><tt>     INTERFACE  PMPI_NEIGHBOR_ALLTOALLW_INIT 
     SUBROUTINE PMPI_NEIGHBOR_ALLTOALLW_INIT_F(a,b,c,d,e,f,g,h,i,j,j,k) 
     INTERFACE  PMPI_NEIGHBOR_ALLGATHERV_INIT 
     SUBROUTINE PMPI_NEIGHBOR_ALLGATHERV_INIT_F(a,b,c,d,e,f,g,h,i,j,k) 
     INTERFACE  PMPI_RGET_ACCUMULATE 
     SUBROUTINE PMPI_RGET_ACCUMULATE_FTS(a,b,c,d,e,f,g,h,i,j,k,l,m,n) 
</tt></pre> 
with 72, 71, and 70 characters.  
In principle, continuation lines would be possible in <tt>mpif.h</tt>  
(spaces in columns 73--131, &amp; in column 132, and in column 6 of the  
continuation line) but this would not be valid if the source line  
length is extended with a compiler flag to 132 characters.  
Column 133 is also not available for the continuation character because  
lines longer than 132 characters are invalid with some compilers by default.  
<P> 
If an implementation applies the rules of  
Table <a href="node469.htm#Table28">28</a> also for the PMPI  
interface, then the longest specific procedure name is  
<font face="sans-serif"> PMPI_Reduce_scatter_block_init_c_f08ts</font>  
with 38 characters in the <tt>mpi_f08</tt> module.  
<P> 
For example, the interface specifications together with the specific procedure names  
can be implemented with  
  
<P><img width=793 height=549 src="img453.gif" alt="Image file"><P>
  
And if interfaces are provided in <tt>mpif.h</tt>, they might look like this  
(outside of any module and in fixed source format):  
<P><img width=804 height=184 src="img454.gif" alt="Image file"><P>
 (<em> End of advice to implementors.</em>) <br> 
 
<br> 
<em> Advice to users.</em>  
<P> 
The following is an example of how  
a user-written or middleware profiling routine  
can be implemented:  
<P><img width=837 height=275 src="img455.gif" alt="Image file"><P>
Note that this routine is used to intercept the existing specific  
procedure name <font face="sans-serif"> MPI_Isend_f08ts</font> in the <font face="sans-serif"> MPI</font> library.  
This routine must not be part of a module.  
This routine itself calls <font face="sans-serif"> PMPI_Isend</font>.  
The <tt>USE</tt> of the <tt>mpi_f08</tt> module is needed for  
definitions of handle types and the interface for <font face="sans-serif"> PMPI_Isend</font>.  
However, this module also contains an interface definition for  
the specific procedure name <font face="sans-serif"> MPI_Isend_f08ts</font> that conflicts  
with the definition of this profiling routine (i.e., the name is  
doubly defined).  
Therefore, the <tt>USE</tt> here specifically excludes the interface  
from the module by renaming the unused routine name in the  
<tt>mpi_f08</tt> module into ``<tt>my_noname</tt>'' in the scope of this routine.  
 (<em> End of advice to users.</em>) <br> 
 
<br> 
<em> Advice to users.</em>  
<P> 
The <font face="sans-serif"> PMPI</font> interface allows intercepting <font face="sans-serif"> MPI</font> routines.  
For example, an additional <font face="sans-serif"> MPI_ISEND</font> profiling wrapper  
can be provided that is called by the  
application and internally calls <font face="sans-serif"> PMPI_ISEND</font>.  
There are two typical use cases: a profiling layer that is developed  
independently from the application and the <font face="sans-serif"> MPI</font> library,  
and profiling routines that are part of the application  
and have access to the application data.  
With <font face="sans-serif"> MPI-3.0</font>, new Fortran interfaces and implementation schemes  
were introduced that have several implications on how Fortran  
<font face="sans-serif"> MPI</font> routines are internally implemented and optimized.  
For profiling layers, these schemes imply that several  
internal interfaces with different specific procedure names  
may need to be intercepted,  
as shown in the example code above.  
Therefore, for wrapper routines that  
are part of a Fortran application,  
it may be more convenient to make the name shift within  
the application, i.e., to substitute the call to the  
<font face="sans-serif"> MPI</font> routine (e.g., <font face="sans-serif"> MPI_ISEND</font>) by a call to a user-written  
profiling wrapper with a new name (e.g., <font face="sans-serif"> X_MPI_ISEND</font>)  
and to call the Fortran <font face="sans-serif"> MPI_ISEND</font> from this wrapper,  
instead of using the <font face="sans-serif"> PMPI</font> interface.  
 (<em> End of advice to users.</em>) <br> 
 
<br> 
<em> Advice  
        to implementors.</em>  
<P> 
An implementation that provides a Fortran interface must provide a  
  combination of <font face="sans-serif"> MPI</font> library and module or include file that uses  
  the specific procedure names as described in  
  Table <a href="node469.htm#Table28">28</a>  
  so that the <font face="sans-serif"> MPI</font>  
  Fortran routines are interceptable as described above.  
 (<em> End of advice to implementors.</em>) <br> 

<P>
<hr>
<a href="node468.htm#Node468"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node464.htm#Node464"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node470.htm#Node470"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node464.htm#Node464"> Support for Fortran</a>
<b>Next: </b><a href="node470.htm#Node470"> <font face="sans-serif"> MPI</font> for Different Fortran Standard Versions</a>
<b>Previous: </b><a href="node468.htm#Node468"> Fortran Support Through the <tt>mpif.h</tt> Include File</a>
<p>
<HR>
Return to <A HREF="node601.htm">MPI-4.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-4.1 of November 2, 2023<BR>
HTML Generated on November 19, 2023
</FONT>
</body>
</html>
