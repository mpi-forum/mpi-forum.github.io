<!DOCTYPE html>
<html lang=en>
<head>
<!-- This file was generated by tohtml from chap-context/context-rendered -->
<!-- with the command
tohtml -default -numbers -dosnl -htables -quietlatex -allgif -endpage mpi4-forum-tail.htm -Wnoredef --mpidoc --latexpgm pdflatex --indexfile mpi41-report-html.idx -basedef mpi4defs.txt -o mpi41-report.tex mpi-report.tex 
-->
<title>Communicator Constructors</title>
</head>
<body style="background-color:#FFFFFF">
<hr><h2><span id="Node188">8.4.2. Communicator Constructors</span></h2>
<a href="node187.htm#Node187"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node186.htm#Node186"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node189.htm#Node189"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node186.htm#Node186"> Communicator Management</a>
<b>Next: </b><a href="node189.htm#Node189"> Communicator Destructors</a>
<b>Previous: </b><a href="node187.htm#Node187"> Communicator Accessors</a>
<p>
  
The following are collective functions that are invoked by all <font face="sans-serif"> MPI</font> processes in the  
group or groups associated with <font face="sans-serif"> comm</font>,  
with the exception of <font face="sans-serif"> MPI_COMM_CREATE_GROUP</font>,  
<font face="sans-serif"> MPI_COMM_CREATE_FROM_GROUP</font>, and  
<font face="sans-serif"> MPI_INTERCOMM_CREATE_FROM_GROUPS</font>.  
<font face="sans-serif"> MPI_COMM_CREATE_GROUP</font> and <font face="sans-serif"> MPI_COMM_CREATE_FROM_GROUP</font>  
are invoked only by the <font face="sans-serif"> MPI</font> processes in the group of the new communicator being constructed.  
<font face="sans-serif"> MPI_INTERCOMM_CREATE_FROM_GROUPS</font> is invoked by  
all the <font face="sans-serif"> MPI</font> processes in the local and remote groups of the new communicator being constructed.  
See the discussion below for the definition of local and remote groups.  
<P> 
 
<br> 
<em> Rationale.</em>  
<P> 
Note that, when using the World Model, there is a chicken-and-egg aspect to <font face="sans-serif"> MPI</font> in that a  
communicator is needed to create a new communicator. In the World Model, the base  
communicator for all <font face="sans-serif"> MPI</font> communicators is predefined outside of <font face="sans-serif"> MPI</font>,  
and is <font face="sans-serif"> MPI_COMM_WORLD</font>. The World Model was arrived at after  
considerable debate, and was chosen to increase ``safety'' of programs  
written in <font face="sans-serif"> MPI</font>.  
 (<em> End of rationale.</em>) <br> 
This chapter presents  
the following communicator construction routines: <font face="sans-serif"> MPI_COMM_CREATE</font>, <font face="sans-serif"> MPI_COMM_DUP</font>,  
<font face="sans-serif"> MPI_COMM_IDUP</font>,<font face="sans-serif"> MPI_COMM_DUP_WITH_INFO</font>, <font face="sans-serif"> MPI_COMM_IDUP_WITH_INFO</font>, <font face="sans-serif"> MPI_COMM_SPLIT</font> and <font face="sans-serif"> MPI_COMM_SPLIT_TYPE</font> can be used to create both intra-communicators and  
inter-communicators; <font face="sans-serif"> MPI_COMM_CREATE_GROUP</font>, <font face="sans-serif"> MPI_COMM_CREATE_FROM_GROUP</font> and  
<font face="sans-serif"> MPI_INTERCOMM_MERGE</font> (see Section <a href="node200.htm#Node200">Inter-Communicator Operations</a>)  
can be used to create  
intra-communicators; <font face="sans-serif"> MPI_INTERCOMM_CREATE</font> and <font face="sans-serif"> MPI_INTERCOMM_CREATE_FROM_GROUPS</font>  
(see Section <a href="node200.htm#Node200">Inter-Communicator Operations</a>)  
can be used to create inter-communicators.  
<P> 
An intra-communicator involves a single group while an inter-communicator  
involves two groups.  
Where the following discussions address inter-communicator semantics,  
the two groups in an inter-communicator are  
called the <em> left</em> and <em> right</em> groups. An <font face="sans-serif"> MPI</font> process in an  
inter-communicator is a member of either the left or the right group. From the  
point of view of that <font face="sans-serif"> MPI</font> process, the  
group that the <font face="sans-serif"> MPI</font> process is a member of is called the <em> local group</em>; the  
other group (relative to that <font face="sans-serif"> MPI</font> process) is the <em> remote group</em>.  
The left and right group labels give us a way to describe the two groups in  
an inter-communicator that is not relative to any particular <font face="sans-serif"> MPI</font> process (as the  
local and remote groups are).  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_COMM_DUP(<span style="white-space:nowrap">comm</span>, <span style="white-space:nowrap">newcomm</span>)</TD></TR>  
<TR><TD> IN comm</TD><TD>communicator (handle)</TD></TR>  
<TR><TD> OUT newcomm</TD><TD>copy of <font face="sans-serif"> comm</font> (handle)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Comm_dup(MPI_Comm comm, MPI_Comm *newcomm) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Comm_dup(comm, newcomm, ierror) <br><br>TYPE(MPI_Comm), INTENT(IN) :: <span style="white-space:nowrap">comm</span> <br>TYPE(MPI_Comm), INTENT(OUT) :: <span style="white-space:nowrap">newcomm</span> <br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_COMM_DUP(COMM, NEWCOMM, IERROR) <br><br>INTEGER <span style="white-space:nowrap">COMM</span>, <span style="white-space:nowrap">NEWCOMM</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
  
<P> 
<font face="sans-serif"> MPI_COMM_DUP</font> duplicates the  
existing communicator <font face="sans-serif"> comm</font> with  
associated key values, topology information and error handlers.  
For each key value, the respective copy callback  
function determines the attribute value associated with this key in the  
new communicator; one particular action that a copy callback may take  
is to delete the attribute from the new communicator.  
<font face="sans-serif"> MPI_COMM_DUP</font> returns in <font face="sans-serif"> newcomm</font> a new  
communicator with the same group or groups, same  
topology, same error handlers and any copied cached information,  
but a new context (see Section <a href="node205.htm#Node205">Functionality</a>).  
The newly created communicator will have no buffer attached (see Section <a href="node69.htm#Node69">Buffer Allocation and Usage</a>).  
<P> 
 
<br> 
<em> Advice to users.</em>  
<P> 
This operation is used to provide a parallel library  
with a duplicate  
communication  
space that has the same properties as the original communicator. This  
includes any attributes (see below) and topologies (see  
Chapter <a href="node218.htm#Node218">Virtual Topologies for <font face="sans-serif"> MPI</font> Processes</a>). This call is valid even if there are  
<em> pending</em>  
point-to-point communication operations  
or <em> decoupled </em><font face="sans-serif"> MPI</font> activities</em> involving  
the communicator  
<font face="sans-serif"> comm</font>. A typical call might involve a <font face="sans-serif"> MPI_COMM_DUP</font>  
at the beginning of the parallel call, and an <font face="sans-serif"> MPI_COMM_FREE</font> of  
that duplicated communicator at the end of the call. Other models  
of communicator management are also possible.  
<P> 
This call applies to both intra- and inter-communicators.  
 (<em> End of advice to users.</em>) <br> 
 
<br> 
<em> Advice  
        to implementors.</em>  
<P> 
One need not actually copy the group information, but only add a new reference  
and increment the reference count. Copy on write can be used for the cached  
information. (<em> End of advice to implementors.</em>) <br> 
<TABLE><TR><TD COLSPAN=2>MPI_COMM_DUP_WITH_INFO(<span style="white-space:nowrap">comm</span>, <span style="white-space:nowrap">info</span>, <span style="white-space:nowrap">newcomm</span>)</TD></TR>  
<TR><TD> IN comm</TD><TD>communicator (handle)</TD></TR>  
<TR><TD> IN info</TD><TD>info object (handle)</TD></TR>  
<TR><TD> OUT newcomm</TD><TD>copy of <font face="sans-serif"> comm</font> (handle)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Comm_dup_with_info(MPI_Comm comm, MPI_Info info, MPI_Comm *newcomm) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Comm_dup_with_info(comm, info, newcomm, ierror) <br><br>TYPE(MPI_Comm), INTENT(IN) :: <span style="white-space:nowrap">comm</span> <br>TYPE(MPI_Info), INTENT(IN) :: <span style="white-space:nowrap">info</span> <br>TYPE(MPI_Comm), INTENT(OUT) :: <span style="white-space:nowrap">newcomm</span> <br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_COMM_DUP_WITH_INFO(COMM, INFO, NEWCOMM, IERROR) <br><br>INTEGER <span style="white-space:nowrap">COMM</span>, <span style="white-space:nowrap">INFO</span>, <span style="white-space:nowrap">NEWCOMM</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
<font face="sans-serif"> MPI_COMM_DUP_WITH_INFO</font> behaves exactly as  
<font face="sans-serif"> MPI_COMM_DUP</font> except that the  
hints provided by the argument <font face="sans-serif"> info</font> are  
associated with the output communicator <font face="sans-serif"> newcomm</font>.  
<P> 
 
<br> 
<em> Rationale.</em>  
<P> 
It is expected that some hints will only be valid at communicator  
creation time. However, for legacy reasons, most communicator creation  
calls do not provide an info argument. One may associate info hints  
with a duplicate of any communicator at creation time through a call  
to <font face="sans-serif"> MPI_COMM_DUP_WITH_INFO</font>.  
 (<em> End of rationale.</em>) <br> 
<TABLE><TR><TD COLSPAN=2>MPI_COMM_IDUP(<span style="white-space:nowrap">comm</span>, <span style="white-space:nowrap">newcomm</span>, <span style="white-space:nowrap">request</span>)</TD></TR>  
<TR><TD> IN comm</TD><TD>communicator (handle)</TD></TR>  
<TR><TD> OUT newcomm</TD><TD>copy of <font face="sans-serif"> comm</font> (handle)</TD></TR>  
<TR><TD> OUT request</TD><TD>communication request (handle)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Comm_idup(MPI_Comm comm, MPI_Comm *newcomm, MPI_Request *request) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Comm_idup(comm, newcomm, request, ierror) <br><br>TYPE(MPI_Comm), INTENT(IN) :: <span style="white-space:nowrap">comm</span> <br>TYPE(MPI_Comm), INTENT(OUT), ASYNCHRONOUS :: <span style="white-space:nowrap">newcomm</span> <br>TYPE(MPI_Request), INTENT(OUT) :: <span style="white-space:nowrap">request</span> <br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_COMM_IDUP(COMM, NEWCOMM, REQUEST, IERROR) <br><br>INTEGER <span style="white-space:nowrap">COMM</span>, <span style="white-space:nowrap">NEWCOMM</span>, <span style="white-space:nowrap">REQUEST</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
<font face="sans-serif"> MPI_COMM_IDUP</font> is a nonblocking variant of <font face="sans-serif"> MPI_COMM_DUP</font>.  
With the exception of its nonblocking behavior, the semantics  
of <font face="sans-serif"> MPI_COMM_IDUP</font> are as if <font face="sans-serif"> MPI_COMM_DUP</font> was executed at the time  
that <font face="sans-serif"> MPI_COMM_IDUP</font> is called.  
For example, attributes changed  
after <font face="sans-serif"> MPI_COMM_IDUP</font> will not be copied to the new communicator. All  
restrictions and assumptions for nonblocking collective  
operations (see Section <a href="node145.htm#Node145">Nonblocking Collective Operations</a>) apply to <font face="sans-serif"> MPI_COMM_IDUP</font> and  
the returned request.  
<P> 
It is erroneous to use the communicator <font face="sans-serif"> newcomm</font> as an  
input argument to other <font face="sans-serif"> MPI</font> functions before the <font face="sans-serif"> MPI_COMM_IDUP</font>  
operation completes.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_COMM_IDUP_WITH_INFO(<span style="white-space:nowrap">comm</span>, <span style="white-space:nowrap">info</span>, <span style="white-space:nowrap">newcomm</span>, <span style="white-space:nowrap">request</span>)</TD></TR>  
<TR><TD> IN comm</TD><TD>communicator (handle)</TD></TR>  
<TR><TD> IN info</TD><TD>info object (handle)</TD></TR>  
<TR><TD> OUT newcomm</TD><TD>copy of <font face="sans-serif"> comm</font> (handle)</TD></TR>  
<TR><TD> OUT request</TD><TD>communication request (handle)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Comm_idup_with_info(MPI_Comm comm, MPI_Info info, MPI_Comm *newcomm, MPI_Request *request) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Comm_idup_with_info(comm, info, newcomm, request, ierror) <br><br>TYPE(MPI_Comm), INTENT(IN) :: <span style="white-space:nowrap">comm</span> <br>TYPE(MPI_Info), INTENT(IN) :: <span style="white-space:nowrap">info</span> <br>TYPE(MPI_Comm), INTENT(OUT), ASYNCHRONOUS :: <span style="white-space:nowrap">newcomm</span> <br>TYPE(MPI_Request), INTENT(OUT) :: <span style="white-space:nowrap">request</span> <br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_COMM_IDUP_WITH_INFO(COMM, INFO, NEWCOMM, REQUEST, IERROR) <br><br>INTEGER <span style="white-space:nowrap">COMM</span>, <span style="white-space:nowrap">INFO</span>, <span style="white-space:nowrap">NEWCOMM</span>, <span style="white-space:nowrap">REQUEST</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
<font face="sans-serif"> MPI_COMM_IDUP_WITH_INFO</font> is a nonblocking variant of  
<font face="sans-serif"> MPI_COMM_DUP_WITH_INFO</font>. With the exception of its nonblocking behavior, the semantics of  
<font face="sans-serif"> MPI_COMM_IDUP_WITH_INFO</font> are as if  
<font face="sans-serif"> MPI_COMM_DUP_WITH_INFO</font> was executed at the time that  
<font face="sans-serif"> MPI_COMM_IDUP_WITH_INFO</font> is called. For example, attributes or  
info hints changed after <font face="sans-serif"> MPI_COMM_IDUP_WITH_INFO</font> will not be  
copied to the new communicator. All restrictions and assumptions for  
nonblocking collective operations (see Section <a href="node145.htm#Node145">Nonblocking Collective Operations</a>) apply to  
<font face="sans-serif"> MPI_COMM_IDUP_WITH_INFO</font> and the returned request.  
<P> 
It is erroneous to use the communicator <font face="sans-serif"> newcomm</font> as an input argument  
to other <font face="sans-serif"> MPI</font> functions before the <font face="sans-serif"> MPI_COMM_IDUP_WITH_INFO</font>  
operation completes.  
<P> 
 
<br> 
<em> Rationale.</em>  
<P> 
The <font face="sans-serif"> MPI_COMM_IDUP</font> and <font face="sans-serif"> MPI_COMM_IDUP_WITH_INFO</font>  
functions are crucial for the development of purely nonblocking libraries  
(see [<a href="node600.htm#-Bib41">41</a>]).  
 (<em> End of rationale.</em>) <br> 
<TABLE><TR><TD COLSPAN=2>MPI_COMM_CREATE(<span style="white-space:nowrap">comm</span>, <span style="white-space:nowrap">group</span>, <span style="white-space:nowrap">newcomm</span>)</TD></TR>  
<TR><TD> IN comm</TD><TD>communicator (handle)</TD></TR>  
<TR><TD> IN group</TD><TD>group, which is a subset of the group of <font face="sans-serif"> comm</font> (handle)</TD></TR>  
<TR><TD> OUT newcomm</TD><TD>new communicator (handle)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Comm_create(MPI_Comm comm, MPI_Group group, MPI_Comm *newcomm) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Comm_create(comm, group, newcomm, ierror) <br><br>TYPE(MPI_Comm), INTENT(IN) :: <span style="white-space:nowrap">comm</span> <br>TYPE(MPI_Group), INTENT(IN) :: <span style="white-space:nowrap">group</span> <br>TYPE(MPI_Comm), INTENT(OUT) :: <span style="white-space:nowrap">newcomm</span> <br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_COMM_CREATE(COMM, GROUP, NEWCOMM, IERROR) <br><br>INTEGER <span style="white-space:nowrap">COMM</span>, <span style="white-space:nowrap">GROUP</span>, <span style="white-space:nowrap">NEWCOMM</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
 If <font face="sans-serif"> comm</font> is an intra-communicator, this function returns a new communicator <font face="sans-serif"> newcomm</font> with  
communication group defined by the <font face="sans-serif"> group</font> argument. No cached information propagates from  
<font face="sans-serif"> comm</font> to <font face="sans-serif"> newcomm</font> and no virtual topology  
information is added to the created communicator. Each <font face="sans-serif"> MPI</font> process must call  
<font face="sans-serif"> MPI_COMM_CREATE</font> with a  
<font face="sans-serif"> group</font> argument that is a subgroup  
of the group associated with <font face="sans-serif"> comm</font>;  
this could be <font face="sans-serif"> MPI_GROUP_EMPTY</font>. The <font face="sans-serif"> MPI</font> processes  
may specify different values for the <font face="sans-serif"> group</font> argument. If an <font face="sans-serif"> MPI</font> process calls with a nonempty <font face="sans-serif"> group</font>  
then all <font face="sans-serif"> MPI</font> processes in that <font face="sans-serif"> group</font> must call the function with the same <font face="sans-serif"> group</font> as argument,  
that is the same <font face="sans-serif"> MPI</font> processes in the same  
order. Otherwise, the call is erroneous. This  
implies that the set of  
groups specified across the <font face="sans-serif"> MPI</font> processes must be disjoint. If the calling <font face="sans-serif"> MPI</font> process is a member of the group  
given as <font face="sans-serif"> group</font> argument, then <font face="sans-serif"> newcomm</font> is a communicator with <font face="sans-serif"> group</font> as its associated group. In the case  
that an <font face="sans-serif"> MPI</font>  process calls with a <font face="sans-serif"> group</font> to which it does not belong, e.g., <font face="sans-serif"> MPI_GROUP_EMPTY</font>, then <font face="sans-serif"> MPI_COMM_NULL</font>  
is returned as <font face="sans-serif"> newcomm</font>. The function is collective and must be called by all <font face="sans-serif"> MPI</font> processes in the group of <font face="sans-serif"> comm</font>.  
<P> 
  <div style="text-align:center"><P><img width=1001 height=955 src="collective-create.gif" alt="Image file"><P>
</div>  
  <br> 
<b>Figure 17: </b><span id="Figure17">Inter-communicator  
    creation 
    using <font face="sans-serif"> MPI_COMM_CREATE</font> 
extended to inter-communicators. The input groups are those in the grey 
circle.</span><P> 
  
    
 
<br> 
<em> Rationale.</em>  
<P> 
The interface supports the original mechanism from <font face="sans-serif"> MPI-1.1</font>, which required the same <font face="sans-serif"> group</font> in all  
<font face="sans-serif"> MPI</font> processes of <font face="sans-serif"> comm</font>. It was extended in <font face="sans-serif"> MPI-2.2</font> to allow the use of disjoint subgroups in order to allow  
implementations to eliminate unnecessary communication that <font face="sans-serif"> MPI_COMM_SPLIT</font> would incur when the user already  
knows the membership of the disjoint subgroups.  
 (<em> End of rationale.</em>) <br> 
 
<br> 
<em> Rationale.</em>  
<P> 
The requirement that the entire group of <font face="sans-serif"> comm</font> participate in the call  
stems from the following considerations:  
<ul> 
 
<li>It allows the implementation to layer <font face="sans-serif"> MPI_COMM_CREATE</font> on top of  
regular collective communications.  
 
<li>It provides additional safety, in particular in the case where partially  
overlapping groups are used to create new communicators.  
 
<li>It permits implementations to  
sometimes avoid communication related to  
context  
creation.  
</ul> 
<br> 
 (<em> End of rationale.</em>) <br> 
 
<br> 
<em> Advice to users.</em>  
<P> 
<font face="sans-serif"> MPI_COMM_CREATE</font> provides a means to subset a group of <font face="sans-serif"> MPI</font> processes for the  
purpose of separate MIMD computation, with separate communication space.  
<font face="sans-serif"> newcomm</font>, which emerges from  
<font face="sans-serif"> MPI_COMM_CREATE</font>, can be used in  
subsequent calls to <font face="sans-serif"> MPI_COMM_CREATE</font> (or other communicator  
constructors) to  
further subdivide a computation into  
parallel sub-computations. A more general service is provided by  
<font face="sans-serif"> MPI_COMM_SPLIT</font>, below.  
 (<em> End of advice to users.</em>) <br> 
 
<br> 
<em> Advice  
        to implementors.</em>  
<P> 
When calling <font face="sans-serif"> MPI_COMM_DUP</font>, all <font face="sans-serif"> MPI</font> processes call with the same <font face="sans-serif"> group</font>  
(the <font face="sans-serif"> group</font> associated with the communicator).  
When calling <font face="sans-serif"> MPI_COMM_CREATE</font>, the <font face="sans-serif"> MPI</font> processes provide the  
same <font face="sans-serif"> group</font> or disjoint subgroups. For both calls, it is theoretically possible  
to agree on a group-wide unique context with no communication.  
However, local execution of these functions requires  
use of a larger context name space and reduces error checking.  
Implementations may strike various compromises between these  
conflicting goals, such as bulk allocation of multiple contexts in one  
collective operation.  
<P> 
Important: If new communicators are created without synchronizing the  
<font face="sans-serif"> MPI</font> processes involved then the communication system  
must be able to cope with  
messages arriving in a context that has not yet been allocated at the  
receiving <font face="sans-serif"> MPI</font> process.  
 (<em> End of advice to implementors.</em>) <br> 
 If <font face="sans-serif"> comm</font> is an  
inter-communicator, then the output communicator is also an  
intercommunicator  
where the local group consists only of those <font face="sans-serif"> MPI</font> processes contained in  
<font face="sans-serif"> group</font> (see Figure <a href="node188.htm#Figure17">17</a>). The <font face="sans-serif"> group</font>  
argument should only contain those <font face="sans-serif"> MPI</font> processes in the local group of the input  
inter-communicator that are to be a part of <font face="sans-serif"> newcomm</font>.  
All <font face="sans-serif"> MPI</font> processes in the same local group of <font face="sans-serif"> comm</font> must specify the same value for  
<font face="sans-serif"> group</font>, i.e., the same members in the same order.  
If either  
<font face="sans-serif"> group</font> does not specify at least one <font face="sans-serif"> MPI</font> process in the local group of  
the inter-communicator, or if the calling <font face="sans-serif"> MPI</font> process is not included in the  
<font face="sans-serif"> group</font>, <font face="sans-serif"> MPI_COMM_NULL</font> is returned.  
<P> 
 
<br> 
<em> Rationale.</em>  
<P> 
In the case where either the left or right group is empty, a null communicator  
is returned instead of an inter-communicator with <font face="sans-serif"> MPI_GROUP_EMPTY</font>  
because the side with the empty group must return <font face="sans-serif"> MPI_COMM_NULL</font>.  
 (<em> End of rationale.</em>) <br> 
<br><b> Example</b>  
  
Inter-communicator creation.<br>  
The following example illustrates how the first node in the left  
side of an inter-communicator could be joined with all members on the  
right side of an inter-communicator to form a new  
inter-communicator.  
<P><img width=757 height=499 src="img261.gif" alt="Image file"><P>
  
<P> 
  
<TABLE><TR><TD COLSPAN=2>MPI_COMM_CREATE_GROUP(<span style="white-space:nowrap">comm</span>, <span style="white-space:nowrap">group</span>, <span style="white-space:nowrap">tag</span>, <span style="white-space:nowrap">newcomm</span>)</TD></TR>  
<TR><TD> IN comm</TD><TD>intra-communicator (handle)</TD></TR>  
<TR><TD> IN group</TD><TD>group, which is a subset of the group of <font face="sans-serif"> comm</font> (handle)</TD></TR>  
<TR><TD> IN tag</TD><TD>tag (integer)</TD></TR>  
<TR><TD> OUT newcomm</TD><TD>new communicator (handle)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Comm_create_group(MPI_Comm comm, MPI_Group group, int tag, MPI_Comm *newcomm) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Comm_create_group(comm, group, tag, newcomm, ierror) <br><br>TYPE(MPI_Comm), INTENT(IN) :: <span style="white-space:nowrap">comm</span> <br>TYPE(MPI_Group), INTENT(IN) :: <span style="white-space:nowrap">group</span> <br>INTEGER, INTENT(IN) :: <span style="white-space:nowrap">tag</span> <br>TYPE(MPI_Comm), INTENT(OUT) :: <span style="white-space:nowrap">newcomm</span> <br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_COMM_CREATE_GROUP(COMM, GROUP, TAG, NEWCOMM, IERROR) <br><br>INTEGER <span style="white-space:nowrap">COMM</span>, <span style="white-space:nowrap">GROUP</span>, <span style="white-space:nowrap">TAG</span>, <span style="white-space:nowrap">NEWCOMM</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
<font face="sans-serif"> MPI_COMM_CREATE_GROUP</font> is similar to  
<font face="sans-serif"> MPI_COMM_CREATE</font>; however, <font face="sans-serif"> MPI_COMM_CREATE</font> must  
be called by all <font face="sans-serif"> MPI</font> processes in the group of <font face="sans-serif"> comm</font>, whereas  
<font face="sans-serif"> MPI_COMM_CREATE_GROUP</font> must be called by all <font face="sans-serif"> MPI</font> processes in  
<font face="sans-serif"> group</font>, which is a subgroup of the group of <font face="sans-serif"> comm</font>. In  
addition, <font face="sans-serif"> MPI_COMM_CREATE_GROUP</font> requires that  
<font face="sans-serif"> comm</font> is an  
intra-communicator. <font face="sans-serif"> MPI_COMM_CREATE_GROUP</font> returns a new  
intra-communicator, <font face="sans-serif"> newcomm</font>, for which the <font face="sans-serif"> group</font>  
argument defines the communication group. No cached information  
propagates from <font face="sans-serif"> comm</font> to <font face="sans-serif"> newcomm</font> and no virtual topology  
information is added to the created communicator. Each <font face="sans-serif"> MPI</font> process must  
provide a <font face="sans-serif"> group</font> argument that is a subgroup of the group associated  
with <font face="sans-serif"> comm</font>; this could be <font face="sans-serif"> MPI_GROUP_EMPTY</font>. If a  
nonempty group is specified, then all <font face="sans-serif"> MPI</font> processes in that group must  
call the function, and each of these <font face="sans-serif"> MPI</font> processes must provide the same  
arguments, including a group that contains the same members with the  
same ordering. Otherwise the call is erroneous. If the calling <font face="sans-serif"> MPI</font> process  
is a member of the group given as the <font face="sans-serif"> group</font> argument, then  
<font face="sans-serif"> newcomm</font> is a communicator with <font face="sans-serif"> group</font> as its  
associated group. If the calling <font face="sans-serif"> MPI</font> process is not a member of  
<font face="sans-serif"> group</font>, e.g., <font face="sans-serif"> group</font> is <font face="sans-serif"> MPI_GROUP_EMPTY</font>, then  
the call is a local operation and <font face="sans-serif"> MPI_COMM_NULL</font> is returned  
as <font face="sans-serif"> newcomm</font>.  
<P> 
 
<br> 
<em> Rationale.</em>  
<P> 
Functionality similar to <font face="sans-serif"> MPI_COMM_CREATE_GROUP</font> can be  
implemented through repeated <font face="sans-serif"> MPI_INTERCOMM_CREATE</font> and  
<font face="sans-serif"> MPI_INTERCOMM_MERGE</font> calls that start with the  
<font face="sans-serif"> MPI_COMM_SELF</font> communicators at each <font face="sans-serif"> MPI</font> process in  
<font face="sans-serif"> group</font> and build up an intra-communicator with group  
<font face="sans-serif"> group</font> [<a href="node600.htm#-Bib18">18</a>]. Such an algorithm  
requires the creation of many intermediate communicators;  
<font face="sans-serif"> MPI_COMM_CREATE_GROUP</font> can provide a more efficient  
implementation that avoids this overhead.  
 (<em> End of rationale.</em>) <br> 
 
<br> 
<em> Advice to users.</em>  
<P> 
An inter-communicator can be created collectively over <font face="sans-serif"> MPI</font> processes in the union of the local and remote groups by creating the local communicator using <font face="sans-serif"> MPI_COMM_CREATE_GROUP</font> and using that communicator as the local communicator argument to <font face="sans-serif"> MPI_INTERCOMM_CREATE</font>.  
 (<em> End of advice to users.</em>) <br> 
The <font face="sans-serif"> tag</font> argument does not conflict with tags used in  
point-to-point communication and is not permitted to be a wildcard. If  
multiple threads at a given <font face="sans-serif"> MPI</font> process perform concurrent  
<font face="sans-serif"> MPI_COMM_CREATE_GROUP</font> operations, the user must  
distinguish these operations by providing different <font face="sans-serif"> tag</font> or  
<font face="sans-serif"> comm</font> arguments.  
<P> 
 
<br> 
<em> Advice to users.</em>  
<P> 
<font face="sans-serif"> MPI_COMM_CREATE</font> may provide lower overhead than  
<font face="sans-serif"> MPI_COMM_CREATE_GROUP</font> because it can take advantage of  
collective communication on <font face="sans-serif"> comm</font> when constructing <font face="sans-serif"> newcomm</font>.  
 (<em> End of advice to users.</em>) <br> 
<TABLE><TR><TD COLSPAN=2>MPI_COMM_SPLIT(<span style="white-space:nowrap">comm</span>, <span style="white-space:nowrap">color</span>, <span style="white-space:nowrap">key</span>, <span style="white-space:nowrap">newcomm</span>)</TD></TR>  
<TR><TD> IN comm</TD><TD>communicator (handle)</TD></TR>  
<TR><TD> IN color</TD><TD>control of subset assignment (integer)</TD></TR>  
<TR><TD> IN key</TD><TD>control of rank assignment (integer)</TD></TR>  
<TR><TD> OUT newcomm</TD><TD>new communicator (handle)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Comm_split(MPI_Comm comm, int color, int key, MPI_Comm *newcomm) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Comm_split(comm, color, key, newcomm, ierror) <br><br>TYPE(MPI_Comm), INTENT(IN) :: <span style="white-space:nowrap">comm</span> <br>INTEGER, INTENT(IN) :: <span style="white-space:nowrap">color</span>, <span style="white-space:nowrap">key</span> <br>TYPE(MPI_Comm), INTENT(OUT) :: <span style="white-space:nowrap">newcomm</span> <br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_COMM_SPLIT(COMM, COLOR, KEY, NEWCOMM, IERROR) <br><br>INTEGER <span style="white-space:nowrap">COMM</span>, <span style="white-space:nowrap">COLOR</span>, <span style="white-space:nowrap">KEY</span>, <span style="white-space:nowrap">NEWCOMM</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
 This function partitions the group associated with <font face="sans-serif"> comm</font>  
into disjoint subgroups, one for each value of <font face="sans-serif"> color</font>. Each subgroup  
contains all <font face="sans-serif"> MPI</font> processes of the same color. Within each subgroup, the <font face="sans-serif"> MPI</font> processes  
are ranked in the order defined by the value of the argument <font face="sans-serif"> key</font>,  
with ties broken according to their rank in the old group. A new communicator  
is created for each subgroup and returned in <font face="sans-serif"> newcomm</font>. An <font face="sans-serif"> MPI</font> process may  
supply the color value <font face="sans-serif"> MPI_UNDEFINED</font>, in which case <font face="sans-serif"> newcomm</font>  
returns <font face="sans-serif"> MPI_COMM_NULL</font>. This is a collective call, but each <font face="sans-serif"> MPI</font> process  
is permitted to provide different values for <font face="sans-serif"> color</font> and <font face="sans-serif"> key</font>.  
No cached information propagates from <font face="sans-serif"> comm</font> to <font face="sans-serif"> newcomm</font> and no  
virtual topology information is added to the created communicators.  
<P> 
With an intra-communicator <font face="sans-serif"> comm</font>, a call to <font face="sans-serif"> MPI_COMM_CREATE(comm, group, newcomm)</font> is  
equivalent to a call to <font face="sans-serif"> MPI_COMM_SPLIT(comm, color, key, newcomm)</font>, where <font face="sans-serif"> MPI</font> processes  
that are members of their <font face="sans-serif"> group</font> argument provide  
a <font face="sans-serif"> color</font> argument equal to the number of the <font face="sans-serif"> group</font>  
(based on a unique numbering of all disjoint groups) and  
a <font face="sans-serif"> key</font> argument equal to their rank in <font face="sans-serif"> group</font>, and  
all <font face="sans-serif"> MPI</font> processes that are not members of their <font face="sans-serif"> group</font> argument provide  
a <font face="sans-serif"> color</font> argument equal to <font face="sans-serif"> MPI_UNDEFINED</font>.  
The value of <font face="sans-serif"> color</font> must be  
nonnegative or <font face="sans-serif"> MPI_UNDEFINED</font>.  
<P> 
 
<br> 
<em> Advice to users.</em>  
<P> 
This is an extremely powerful mechanism for dividing a single  
communicating group of <font face="sans-serif"> MPI</font> processes into <i>k</i> subgroups, with <i>k</i> chosen  
implicitly by the user (by the number of  
colors asserted over all the <font face="sans-serif"> MPI</font> processes). Each resulting communicator will be  
nonoverlapping. Such a division could be useful for defining a hierarchy  
of computations, such as for multigrid, or linear algebra.  
For intra-communicators, <font face="sans-serif"> MPI_COMM_SPLIT</font> provides similar capability as <font face="sans-serif"> MPI_COMM_CREATE</font>  
to split a communicating group into disjoint subgroups. <font face="sans-serif"> MPI_COMM_SPLIT</font> is useful  
when some <font face="sans-serif"> MPI</font> processes do not have complete information of the other members in their  
group, but all <font face="sans-serif"> MPI</font> processes know (the color of) the group to which they belong.  
In this case, the <font face="sans-serif"> MPI</font> implementation discovers the other group members via  
communication. <font face="sans-serif"> MPI_COMM_CREATE</font> is useful when all <font face="sans-serif"> MPI</font> processes have complete  
information of the members of their group. In this case, <font face="sans-serif"> MPI</font> can avoid the extra  
communication required to discover group membership.  
<font face="sans-serif"> MPI_COMM_CREATE_GROUP</font> is useful when  
all <font face="sans-serif"> MPI</font> processes in a given group have complete information of the members of  
their group and synchronization with <font face="sans-serif"> MPI</font> processes outside the group can be  
avoided.  
<P> 
Multiple calls to <font face="sans-serif"> MPI_COMM_SPLIT</font> can be used to overcome the  
requirement that any call have no overlap of the resulting communicators (each  
<font face="sans-serif"> MPI</font> process is of only one color per call). In this way, multiple overlapping  
communication structures can be created. Creative use of the <font face="sans-serif"> color</font>  
and <font face="sans-serif"> key</font> in such splitting operations is encouraged.  
<P> 
Note that, for a fixed color, the keys need not  
be unique. It is <font face="sans-serif"> MPI_COMM_SPLIT</font>'s responsibility to sort <font face="sans-serif"> MPI</font> processes  
in ascending order according to this key, and to break ties in a consistent  
way. If all the keys are specified in the same way, then all the <font face="sans-serif"> MPI</font> processes  
in a given color will have the relative rank order as they did in their  
parent group.  
<P> 
 (<em> End of advice to users.</em>) <br> 
 
<br> 
<em> Rationale.</em>  
<P> 
<font face="sans-serif"> color</font> is restricted to be nonnegative, so as not to conflict with the value assigned to <font face="sans-serif"> MPI_UNDEFINED</font>.  
 (<em> End of rationale.</em>) <br> 
 The result of <font face="sans-serif"> MPI_COMM_SPLIT</font> on an inter-communicator is that those  
<font face="sans-serif"> MPI</font> processes on the left with the same <font face="sans-serif"> color</font> as those <font face="sans-serif"> MPI</font> processes on  
the right combine to create a new inter-communicator. The <font face="sans-serif"> key</font>  
argument describes the relative rank of <font face="sans-serif"> MPI</font> processes on each side of the  
inter-communicator (see Figure <a href="node188.htm#Figure18">18</a>). For those colors  
that are specified only on one side of the inter-communicator,  
<font face="sans-serif"> MPI_COMM_NULL</font> is returned. <font face="sans-serif"> MPI_COMM_NULL</font>  
is also returned to those <font face="sans-serif"> MPI</font> processes that specify <font face="sans-serif"> MPI_UNDEFINED</font>  
as the color.  
 
<br> 
<em> Advice to users.</em>  
<P> 
For inter-communicators, <font face="sans-serif"> MPI_COMM_SPLIT</font> is more general than <font face="sans-serif"> MPI_COMM_CREATE</font>.  
A single call to <font face="sans-serif"> MPI_COMM_SPLIT</font> can create a set of disjoint inter-communicators,  
while a call to <font face="sans-serif"> MPI_COMM_CREATE</font> creates only one.  
 (<em> End of advice to users.</em>) <br> 
  <div style="text-align:center"><P><img width=557 height=884 src="collective-split2.gif" alt="Image file"><P>
</div>  
  <br> 
<b>Figure 18: </b><span id="Figure18">Inter-communicator construction achieved by splitting an 
    existing inter-communicator with <font face="sans-serif"> MPI_COMM_SPLIT</font> 
extended to inter-communicators.</span><P> 
  
    
<br><b> Example</b>  
  
Parallel client-server model.<br>  
The following client code illustrates how clients on the left side of an  
inter-communicator could be assigned to a single server from a pool of  
servers on the right side of an inter-communicator.  
<P><img width=729 height=474 src="img262.gif" alt="Image file"><P>
 The following is the corresponding server code:  
<P><img width=758 height=349 src="img263.gif" alt="Image file"><P>
  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_COMM_SPLIT_TYPE(<span style="white-space:nowrap">comm</span>, <span style="white-space:nowrap">split_type</span>, <span style="white-space:nowrap">key</span>, <span style="white-space:nowrap">info</span>, <span style="white-space:nowrap">newcomm</span>)</TD></TR>  
<TR><TD> IN comm</TD><TD>communicator (handle)</TD></TR>  
<TR><TD> IN split_type</TD><TD>type of processes to be grouped together (integer)</TD></TR>  
<TR><TD> IN key</TD><TD>control of rank assignment (integer)</TD></TR>  
<TR><TD> INOUT info</TD><TD>info argument (handle)</TD></TR>  
<TR><TD> OUT newcomm</TD><TD>new communicator (handle)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Comm_split_type(MPI_Comm comm, int split_type, int key, MPI_Info info, MPI_Comm *newcomm) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Comm_split_type(comm, split_type, key, info, newcomm, ierror) <br><br>TYPE(MPI_Comm), INTENT(IN) :: <span style="white-space:nowrap">comm</span> <br>INTEGER, INTENT(IN) :: <span style="white-space:nowrap">split_type</span>, <span style="white-space:nowrap">key</span> <br>TYPE(MPI_Info), INTENT(IN) :: <span style="white-space:nowrap">info</span> <br>TYPE(MPI_Comm), INTENT(OUT) :: <span style="white-space:nowrap">newcomm</span> <br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_COMM_SPLIT_TYPE(COMM, SPLIT_TYPE, KEY, INFO, NEWCOMM, IERROR) <br><br>INTEGER <span style="white-space:nowrap">COMM</span>, <span style="white-space:nowrap">SPLIT_TYPE</span>, <span style="white-space:nowrap">KEY</span>, <span style="white-space:nowrap">INFO</span>, <span style="white-space:nowrap">NEWCOMM</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
 This function partitions the group associated with  
<font face="sans-serif"> comm</font> into disjoint subgroups such that each subgroup contains  
all <font face="sans-serif"> MPI</font> processes in the same grouping referred to by <font face="sans-serif"> split_type</font>.  
Within each subgroup, the <font face="sans-serif"> MPI</font> processes are ranked in the order  
defined by the value of the argument <font face="sans-serif"> key</font>, with ties broken  
according to their rank in the old group. A new communicator is  
created for each subgroup and returned in <font face="sans-serif"> newcomm</font>. This is a  
collective call. All <font face="sans-serif"> MPI</font> processes in the group associated with  
<font face="sans-serif"> comm</font> must provide the same <font face="sans-serif"> split_type</font>, but each  
<font face="sans-serif"> MPI</font> process is permitted to provide different values for <font face="sans-serif"> key</font>.  
An exception to this rule is that an <font face="sans-serif"> MPI</font> process may supply the type  
value <font face="sans-serif"> MPI_UNDEFINED</font>, in which case <font face="sans-serif"> MPI_COMM_NULL</font> is  
returned in <font face="sans-serif"> newcomm</font> for such <font face="sans-serif"> MPI</font> process.  
No cached information propagates from <font face="sans-serif"> comm</font> to <font face="sans-serif"> newcomm</font> and no  
virtual topology information is added to the created communicators.  
<P> 
For <font face="sans-serif"> split_type</font>, the following values are defined by <font face="sans-serif"> MPI</font>:  
<P> 
<dl> 
 
<dt> 
<b><font face="sans-serif"> MPI_COMM_TYPE_SHARED</font>:</b><dd> 
all <font face="sans-serif"> MPI</font> processes in the group of <font face="sans-serif"> newcomm</font>  
  are part of the same <em> shared memory domain</em> and  
  can create a <em> shared memory segment</em>  
  (e.g., with a successful call to <font face="sans-serif"> MPI_WIN_ALLOCATE_SHARED</font>).  
  This segment can subsequently be used for load/store accesses by all <font face="sans-serif"> MPI</font> processes in <font face="sans-serif"> newcomm</font>.  
<P> 
 
<br> 
<em> Advice to users.</em>  
<P> 
Since the location of some of the <font face="sans-serif"> MPI</font> processes may change during the application execution,  
    the communicators created with the value <font face="sans-serif"> MPI_COMM_TYPE_SHARED</font> before this change may not  
    reflect an actual ability to share memory between <font face="sans-serif"> MPI</font> processes after this change.  
   (<em> End of advice to users.</em>) <br> 
 
<dt> 
<b><font face="sans-serif"> MPI_COMM_TYPE_HW_GUIDED</font>:</b><dd> 
this  
  value specifies that the communicator <font face="sans-serif"> comm</font> is split according to a  
  <b> hardware resource type</b> (for example a computing core or an L3 cache)  
  specified by the <font face="sans-serif"> mpi_hw_resource_type</font> info key. Each output communicator  
  <font face="sans-serif"> newcomm</font> corresponds to a single instance of the specified hardware resource type.  
  The <font face="sans-serif"> MPI</font> processes in the group associated with the output communicator <font face="sans-serif"> newcomm</font>  
  utilize that specific hardware resource type instance, and no other instance of the same  
  hardware resource type.  
<P> 
If an <font face="sans-serif"> MPI</font> process does not meet the above criteria, then <font face="sans-serif"> MPI_COMM_NULL</font> is returned  
  in <font face="sans-serif"> newcomm</font> for such <font face="sans-serif"> MPI</font> process.  
<P> 
<font face="sans-serif"> MPI_COMM_NULL</font> is also returned in <font face="sans-serif"> newcomm</font> in the following cases:  
  <ul> 
   
<li><font face="sans-serif"> MPI_INFO_NULL</font> is provided.  
   
<li>The <font face="sans-serif"> info</font> handle does not include the key <font face="sans-serif"> mpi_hw_resource_type</font>.  
   
<li>The <font face="sans-serif"> MPI</font> implementation neither recognizes nor supports the info key <font face="sans-serif"> mpi_hw_resource_type</font>.  
   
<li>The <font face="sans-serif"> MPI</font> implementation does not recognize the value associated with the info key <font face="sans-serif"> mpi_hw_resource_type</font>.  
  </ul> 
<br> 
The <font face="sans-serif"> MPI</font> implementation will return in the group of the output communicator <font face="sans-serif"> newcomm</font>  
  the largest subset of <font face="sans-serif"> MPI</font> processes that match the splitting criterion.  
<P> 
The <font face="sans-serif"> MPI</font> processes in the group associated with <font face="sans-serif"> newcomm</font> are ranked in the order defined by  
  the value of the argument <font face="sans-serif"> key</font> with ties broken according to their rank in the group  
  associated with <font face="sans-serif"> comm</font>.  
  <P> 
 
<br> 
<em> Advice to users.</em>  
<P> 
The set of hardware resources that an <font face="sans-serif"> MPI</font> process is able to utilize may change during the  
    application execution (e.g., because of the relocation of an <font face="sans-serif"> MPI</font> process), in which case the communicators  
    created with the value <font face="sans-serif"> MPI_COMM_TYPE_HW_GUIDED</font> before this change may not reflect  
    the utilization of hardware resources of such <font face="sans-serif"> MPI</font> process at any time after the communicator creation.   
   (<em> End of advice to users.</em>) <br> 
The user explicitly constrains with the <font face="sans-serif"> info</font> argument the splitting of the input communicator  
  <font face="sans-serif"> comm</font>. To this end, the info key <font face="sans-serif"> mpi_hw_resource_type</font> is reserved and its associated  
  value is an implementation-defined string designating the type of the requested hardware  
  resource (e.g., ``NUMANode'', ``Package'' or ``L3Cache'').  
<P> 
The value <font face="sans-serif"> mpi_shared_memory</font> is reserved and its use is equivalent to using <font face="sans-serif"> MPI_COMM_TYPE_SHARED</font>  
  for the <font face="sans-serif"> split_type</font> parameter.  
   
<br> 
<em> Rationale.</em>  
<P> 
The value <font face="sans-serif"> mpi_shared_memory</font> is defined in order to ensure consistency between  
    the use of <font face="sans-serif"> MPI_COMM_TYPE_SHARED</font> and the use of <font face="sans-serif"> MPI_COMM_TYPE_HW_GUIDED</font>.  
   (<em> End of rationale.</em>) <br> 
All <font face="sans-serif"> MPI</font> processes must provide the same value for the info key <font face="sans-serif"> mpi_hw_resource_type</font>.  
<P> 
<br><b> Example</b>  
    
    Splitting <font face="sans-serif"> MPI_COMM_WORLD</font> into NUMANode subcommunicators.  
<P><img width=729 height=250 src="img264.gif" alt="Image file"><P>
  
<P> 
 
<dt> 
<b><font face="sans-serif"> MPI_COMM_TYPE_RESOURCE_GUIDED</font>:</b><dd> 
this  
  value specifies that the communicator <font face="sans-serif"> comm</font> is split according to a  
  <b> hardware resource type</b> (for example a computing core or an L3 cache)  
  specified by the <font face="sans-serif"> mpi_hw_resource_type</font> info key or to a <b> logical resource type</b>  
  (for example a process set name, see Section <a href="node273.htm#Node273">Processes Sets</a>)  
  specified by the <font face="sans-serif"> mpi_pset_name</font> info key.  
<P> 
Each output communicator <font face="sans-serif"> newcomm</font> corresponds to a single instance of the specified resource type.  
  The <font face="sans-serif"> MPI</font> processes in the group associated with the output communicator <font face="sans-serif"> newcomm</font>  
  utilize that specific resource type instance, and no other instance of the same resource type.  
<P> 
If an <font face="sans-serif"> MPI</font> process does not meet the above criteria, then <font face="sans-serif"> MPI_COMM_NULL</font> is returned  
  in <font face="sans-serif"> newcomm</font> for such process.  
<P> 
<font face="sans-serif"> MPI_COMM_NULL</font> is also returned in <font face="sans-serif"> newcomm</font> in the following cases:  
  <ul> 
   
<li><font face="sans-serif"> MPI_INFO_NULL</font> is provided.  
   
<li>The <font face="sans-serif"> info</font> handle includes neither the key <font face="sans-serif"> mpi_hw_resource_type</font> nor the key <font face="sans-serif"> mpi_pset_name</font>.  
   
<li>The <font face="sans-serif"> MPI</font> implementation neither recognizes nor supports the info keys <font face="sans-serif"> mpi_hw_resource_type</font> and <font face="sans-serif"> mpi_pset_name</font>.  
   
<li>The <font face="sans-serif"> MPI</font> implementation does not recognize the value associated with the info key <font face="sans-serif"> mpi_hw_resource_type</font> or <font face="sans-serif"> mpi_pset_name</font>.  
  </ul> 
<br> 
The <font face="sans-serif"> MPI</font> implementation will return in the group of the output communicator <font face="sans-serif"> newcomm</font>  
  the largest subset of <font face="sans-serif"> MPI</font> processes that match the splitting criterion.  
<P> 
 
<br> 
<em> Advice to users.</em>  
<P> 
The set of resources that an <font face="sans-serif"> MPI</font> process is able to utilize may change during the  
    application execution (e.g., because of the relocation of an <font face="sans-serif"> MPI</font> process), in which case the communicators  
    created with the value <font face="sans-serif"> MPI_COMM_TYPE_RESOURCE_GUIDED</font> before this change may not reflect  
    the utilization of resources of such process at any time after the communicator creation.  
   (<em> End of advice to users.</em>) <br> 
The user explicitly constrains with the <font face="sans-serif"> info</font> argument the splitting of the input communicator  
  <font face="sans-serif"> comm</font>. To this end, the following info keys are reserved and their associated values  
  are implementation-defined strings designating the type of the requested resource. Only one of these info  
  keys can be used in <font face="sans-serif"> info</font> at a time in a call to <font face="sans-serif"> MPI_COMM_SPLIT_TYPE</font>; use of more than  
  one info key is erroneous.  
<P> 
<dl> 
   
<dt> 
<b></b><dd> 
<font face="sans-serif"> mpi_hw_resource_type</font> is used to specify the type of a requested hardware resource (e.g., ``NUMANode'',  
    ``Package'' or ``L3Cache''). The value <font face="sans-serif"> mpi_shared_memory</font> is reserved and its use is equivalent  
    to using <font face="sans-serif"> MPI_COMM_TYPE_SHARED</font> for the <font face="sans-serif"> split_type</font> parameter.  
     
<br> 
<em> Rationale.</em>  
<P> 
The value <font face="sans-serif"> mpi_shared_memory</font> is defined in order to ensure consistency between  
      the use of <font face="sans-serif"> MPI_COMM_TYPE_SHARED</font> and the use of <font face="sans-serif"> MPI_COMM_TYPE_RESOURCE_GUIDED</font>.  
     (<em> End of rationale.</em>) <br> 
All <font face="sans-serif"> MPI</font> processes in the group of the input communicator <font face="sans-serif"> comm</font> must provide the same info key to perform the splitting action.  
    All <font face="sans-serif"> MPI</font> processes in the group of the input communicator <font face="sans-serif"> comm</font> must provide the same value for the info key <font face="sans-serif"> mpi_hw_resource_type</font>.  
<P> 
 
<dt> 
<b></b><dd> 
<font face="sans-serif"> mpi_pset_name</font> is used to specify the type of a requested logical resource through the utilization  
    of a process set name (e.g., ``app://ocean'' or ``app://atmos''). This process set name must be valid in the session  
    from which the input communicator <font face="sans-serif"> comm</font> is derived. If this input communicator is not derived from a session,  
    then <font face="sans-serif"> MPI_COMM_NULL</font> is returned in <font face="sans-serif"> newcomm</font>.  
<P> 
All <font face="sans-serif"> MPI</font> processes that are both in the group of the input communicator <font face="sans-serif"> comm</font> and in the process set identified by the given process set name  
    must provide the same info key to perform the splitting action.  
    All <font face="sans-serif"> MPI</font> processes that are both in the group of the input communicator <font face="sans-serif"> comm</font> and in the process set identified by the given process set name  
    must provide the same value for the info key <font face="sans-serif"> mpi_pset_name</font>.  
  </dl> 
<br> 
<br><b> Example</b>  
  
Splitting <font face="sans-serif"> MPI_COMM_WORLD</font> into NUMANode subcommunicators.  
<P><img width=729 height=250 src="img265.gif" alt="Image file"><P>
  
<P> 
 
<dt> 
<b><font face="sans-serif"> MPI_COMM_TYPE_HW_UNGUIDED</font>:</b><dd> 
the group of <font face="sans-serif"> MPI</font> processes associated  
  with <font face="sans-serif"> newcomm</font> must be a <em> strict</em> subset of the group associated with <font face="sans-serif"> comm</font> and  
  each <font face="sans-serif"> newcomm</font> corresponds to a single instance of a <b> hardware resource type</b>  
  (for example a computing core or an L3 cache).  
<P> 
All <font face="sans-serif"> MPI</font> processes in the group associated with <font face="sans-serif"> comm</font> that utilize that specific hardware resource  
  type instance---and no other instance of the same hardware resource type---are included in the group of  
  <font face="sans-serif"> newcomm</font>.  
  <P> 
If a given <font face="sans-serif"> MPI</font> process cannot be a member of a communicator that forms such a strict subset,  
  or does not meet the above criteria, then <font face="sans-serif"> MPI_COMM_NULL</font> is returned in <font face="sans-serif"> newcomm</font>  
  for this process.  
<P> 
 
<br> 
<em> Advice  
        to implementors.</em>  
<P> 
In a high-quality <font face="sans-serif"> MPI</font> implementation, the number of different new valid communicators  
    <font face="sans-serif"> newcomm</font> produced by this splitting operation should be minimal unless the user  
    provides a key/value pair that modifies this behavior. The sets of hardware resource types  
    used for the splitting operation are implementation-dependent, but should reflect the hardware  
    of the actual system on which the application is currently executing.  
   (<em> End of advice to implementors.</em>) <br> 
 
<br> 
<em> Rationale.</em>  
<P> 
If the hardware resources are hierarchically organized, calling this routine several times  
    using as its input communicator <font face="sans-serif"> comm</font> the output communicator <font face="sans-serif"> newcomm</font> of the  
    previous call creates a sequence of <font face="sans-serif"> newcomm</font> communicators in each <font face="sans-serif"> MPI</font> process, which  
    exposes a hierarchical view of the hardware platform, as shown in Example <a href="node188.htm#Node188">Communicator Constructors</a>.  
    This sequence of returned <font face="sans-serif"> newcomm</font> communicators may differ from the sets of hardware  
    resource types, as shown in the second splitting operation in Figure <a href="node188.htm#Figure19">19</a>.  
   (<em> End of rationale.</em>) <br> 
 
<br> 
<em> Advice to users.</em>  
<P> 
Each output communicator <font face="sans-serif"> newcomm</font> can represent a different hardware resource type  
    (see Figure <a href="node188.htm#Figure19">19</a> for an example). The set of hardware resources  
    an <font face="sans-serif"> MPI</font> process utilizes may change during the application execution (e.g., because  
    of <font face="sans-serif"> MPI</font> process relocation), in which case the communicators created with the value  
    <font face="sans-serif"> MPI_COMM_TYPE_HW_UNGUIDED</font> before this change may not reflect the utilization of  
    hardware resources for such <font face="sans-serif"> MPI</font> process at any time after the communicator creation.  
   (<em> End of advice to users.</em>) <br> 
    <div style="text-align:center"><P><img width=1170 height=1620 src="recursive_split.gif" alt="Image file"><P>
</div>  
    <br> 
<b>Figure 19: </b><span id="Figure19">Recursive splitting of 
      <font face="sans-serif"> MPI_COMM_WORLD</font> with <font face="sans-serif"> MPI_COMM_SPLIT_TYPE</font> and <font face="sans-serif"> MPI_COMM_TYPE_HW_UNGUIDED</font>. 
      Dashed lines represent communicators whilst solid lines represent hardware resources. <font face="sans-serif"> MPI</font> processes (P0 to 
      P11) utilize exclusively their respective core, except for P6 and P7, which utilize 
      CPU #3 of Rack #0 and can therefore use Cores #6 and #7 indifferently. The second splitting operation 
      yields two subcommunicators corresponding to NUMANodes in Rack #0 and to CPUs in Rack #1 because Rack #1 
      features only one NUMANode, which corresponds to the whole portion of the Rack that is included in 
      <font face="sans-serif"> MPI_COMM_WORLD</font> and <tt>hwcomm[1]</tt>. 
      For the first splitting operation, the hardware resource type returned in the info argument is ``Rack'' 
      on the <font face="sans-serif"> MPI</font> processes on Rack #0, whereas on Rack #1, it can be either ``Rack'' or ``NUMANode''. 
    </span><P> 
  
      
  If a valid info handle is provided as an argument, the <font face="sans-serif"> MPI</font> implementation sets the info key  
  <font face="sans-serif"> mpi_hw_resource_type</font> for each <font face="sans-serif"> MPI</font> process in the group associated with a returned  
  <font face="sans-serif"> newcomm</font> communicator and the info key value is an implementation-defined string that  
  indicates the hardware resource type represented by <font face="sans-serif"> newcomm</font>. The same hardware resource  
  type must be set in all <font face="sans-serif"> MPI</font> processes in the group associated with <font face="sans-serif"> newcomm</font>.  
      <P> 
<br><b> Example</b>  
    
    Recursive splitting of <font face="sans-serif"> MPI_COMM_WORLD</font>.  
<P><img width=729 height=424 src="img266.gif" alt="Image file"><P>
  
 <P> 
</dl> 
<br> 
 
<br> 
<em> Advice  
        to implementors.</em>  
<P> 
Implementations can define their own <font face="sans-serif"> split_type</font> values, or use the <font face="sans-serif"> info</font> argument, to  
  assist in creating communicators that help expose platform-specific information to the application.  
  The concept of hardware-based communicators was first described by Tr&#228;ff [<a href="node600.htm#-Bib68">68</a>] for SMP systems.  
  Guided and unguided modes description as well as an implementation path are introduced by  
  Goglin et al. [<a href="node600.htm#-Bib28">28</a>].  
 (<em> End of advice to implementors.</em>) <br> 
<TABLE><TR><TD COLSPAN=2>MPI_COMM_CREATE_FROM_GROUP(<span style="white-space:nowrap">group</span>, <span style="white-space:nowrap">stringtag</span>, <span style="white-space:nowrap">info</span>, <span style="white-space:nowrap">errhandler</span>, <span style="white-space:nowrap">newcomm</span>)</TD></TR>  
<TR><TD> IN group</TD><TD>group (handle)</TD></TR>  
<TR><TD> IN stringtag</TD><TD>unique identifier for this operation (string)</TD></TR>  
<TR><TD> IN info</TD><TD>info object (handle)</TD></TR>  
<TR><TD> IN errhandler</TD><TD>error handler to be attached to new intra-communicator (handle)</TD></TR>  
<TR><TD> OUT newcomm</TD><TD>new communicator (handle)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Comm_create_from_group(MPI_Group group, const char *stringtag, MPI_Info info, MPI_Errhandler errhandler, MPI_Comm *newcomm) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Comm_create_from_group(group, stringtag, info, errhandler, newcomm, ierror) <br><br>TYPE(MPI_Group), INTENT(IN) :: <span style="white-space:nowrap">group</span> <br>CHARACTER(LEN=*), INTENT(IN) :: <span style="white-space:nowrap">stringtag</span> <br>TYPE(MPI_Info), INTENT(IN) :: <span style="white-space:nowrap">info</span> <br>TYPE(MPI_Errhandler), INTENT(IN) :: <span style="white-space:nowrap">errhandler</span> <br>TYPE(MPI_Comm), INTENT(OUT) :: <span style="white-space:nowrap">newcomm</span> <br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_COMM_CREATE_FROM_GROUP(GROUP, STRINGTAG, INFO, ERRHANDLER, NEWCOMM, IERROR) <br><br>INTEGER <span style="white-space:nowrap">GROUP</span>, <span style="white-space:nowrap">INFO</span>, <span style="white-space:nowrap">ERRHANDLER</span>, <span style="white-space:nowrap">NEWCOMM</span>, <span style="white-space:nowrap">IERROR</span> <br>CHARACTER*(*) <span style="white-space:nowrap">STRINGTAG</span> <br></tt>  
<P> 
<font face="sans-serif"> MPI_COMM_CREATE_FROM_GROUP</font> is similar to  
<font face="sans-serif"> MPI_COMM_CREATE_GROUP</font>, except that the set of <font face="sans-serif"> MPI</font> processes  
involved in the creation of the new intra-communicator is specified by a  
<font face="sans-serif"> group</font> argument, rather than the group associated with a pre-existing communicator.  
If a nonempty <font face="sans-serif"> group</font> is specified, then  
all <font face="sans-serif"> MPI</font> processes in that group must call the function and  
each of these <font face="sans-serif"> MPI</font> processes must provide the same arguments,  
including a group that contains the same members with the same ordering,  
and identical <font face="sans-serif"> stringtag</font> value.  
In the event that <font face="sans-serif"> MPI_GROUP_EMPTY</font> is supplied as the <font face="sans-serif"> group</font> argument, then  
the call is a local operation and <font face="sans-serif"> MPI_COMM_NULL</font> is returned as <font face="sans-serif"> newcomm</font>.  
The <font face="sans-serif"> stringtag</font> argument is analogous to the <font face="sans-serif"> tag</font> used for <font face="sans-serif"> MPI_COMM_CREATE_GROUP</font>.  
If multiple threads at a given <font face="sans-serif"> MPI</font> process perform concurrent  
<font face="sans-serif"> MPI_COMM_CREATE_FROM_GROUP</font> operations, the user must  
distinguish these operations by providing different <font face="sans-serif"> stringtag</font> arguments.  
The <font face="sans-serif"> stringtag</font> shall not exceed <font face="sans-serif"> MPI_MAX_STRINGTAG_LEN</font>  characters in length.  
For C, this includes space for a null terminating character.  
<font face="sans-serif"> MPI_MAX_STRINGTAG_LEN</font> shall have a value of at least 63.  
<P> 
The <font face="sans-serif"> errhandler</font> argument specifies an  
error handler to be attached to the new intra-communicator.  
Section <a href="node252.htm#Node252">Error Handling</a> specifies the error handler to be invoked if  
an error is encountered during the invocation of <font face="sans-serif"> MPI_COMM_CREATE_FROM_GROUP</font>.  
<P> 
The <font face="sans-serif"> info</font> argument provides hints and assertions,  
possibly <font face="sans-serif"> MPI</font> implementation dependent,  
which indicate desired characteristics and guide communicator creation.  
<P> 
 
<br> 
<em> Advice to users.</em>  
<P> 
The <font face="sans-serif"> stringtag</font> argument is used to distinguish concurrent communicator construction operations  
issued by different entities. As such, it is important to ensure that this argument is unique  
for each concurrent call to <font face="sans-serif"> MPI_COMM_CREATE_FROM_GROUP</font>.  
Reverse domain name notation convention [<a href="node600.htm#-Bib2">2</a>] is one approach to constructing unique <font face="sans-serif"> stringtag</font> arguments.  
See also example <a href="node275.htm#Node275">Sessions Model Examples</a>.  
 (<em> End of advice to users.</em>) <br> 

<P>
<hr>
<a href="node187.htm#Node187"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node186.htm#Node186"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node189.htm#Node189"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node186.htm#Node186"> Communicator Management</a>
<b>Next: </b><a href="node189.htm#Node189"> Communicator Destructors</a>
<b>Previous: </b><a href="node187.htm#Node187"> Communicator Accessors</a>
<p>
<HR>
Return to <A HREF="node601.htm">MPI-4.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-4.1 of November 2, 2023<BR>
HTML Generated on November 19, 2023
</FONT>
</body>
</html>
