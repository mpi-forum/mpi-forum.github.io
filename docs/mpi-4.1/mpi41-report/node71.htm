<!DOCTYPE html>
<html lang=en>
<head>
<!-- This file was generated by tohtml from chap-pt2pt/pt2pt-rendered -->
<!-- with the command
tohtml -default -numbers -dosnl -htables -quietlatex -allgif -endpage mpi4-forum-tail.htm -Wnoredef --mpidoc --latexpgm pdflatex --indexfile mpi41-report-html.idx -basedef mpi4defs.txt -o mpi41-report.tex mpi-report.tex 
-->
<title>Nonblocking Communication</title>
</head>
<body style="background-color:#FFFFFF">
<hr><h1><span id="Node71">4.7. Nonblocking Communication</span></h1>
<a href="node70.htm#Node70"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node53.htm#Node53"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node72.htm#Node72"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node53.htm#Node53"> Point-to-Point Communication</a>
<b>Next: </b><a href="node72.htm#Node72"> Communication Request Objects</a>
<b>Previous: </b><a href="node70.htm#Node70"> Model Implementation of Buffered Mode</a>
<p>
  
  
  
<P> 
<b> Nonblocking communication</b>  
is important both for reasons of correctness and performance.  
For complex communication patterns, the use of only blocking communication  
(without buffering) is difficult because the programmer must ensure that  
each send is matched with a receive in an order that  
avoids <em> deadlock</em>.  
For communication patterns that are determined only at run time, this is even  
more difficult.  
Nonblocking communication can be used to avoid this problem, allowing programmers to  
express complex and possibly dynamic communication patterns without needing to  
ensure that all sends and receives are issued in an order that prevents  
deadlock (see Section <a href="node68.htm#Node68">Semantics of Point-to-Point Communication</a> and the discussion of ``safe'' programs).  
Nonblocking communication also allows for the <em> overlap</em>  
of communication with different communication operations,  
e.g., to prevent the unintentional <em> serialization</em> of such operations,  
and for the <em> overlap</em>  
of communication with computation.  
Whether an implementation is able to accomplish an effective (from a  
performance standpoint) overlap of operations depends on the implementation  
itself and the system on which the implementation is running.  
Using nonblocking operations <em> permits</em> an implementation to overlap  
communication with computation, but does not require it to do so.  
<P> 
A nonblocking <b> send start</b> call <em> initiates</em> the send operation, but does not  
complete it.  The send start call  
can  
return before the message was copied out of the send buffer.  
A separate <b> send complete</b>  
call is needed to complete the communication, i.e., to verify that the  
data has been copied out of the send buffer.  With  
suitable hardware, the transfer of data out of the sender memory  
may proceed concurrently with computations done at the sender after  
the send was initiated and before it completed.  
Similarly, a nonblocking <b> receive start</b> call <em> initiates</em> the receive  
operation, but does not complete it.  The call  
can  
return before  
a message is stored into the receive buffer.  A separate  
<b> receive complete</b> call  
is needed to complete the receive operation and verify that the data has  
been received into the receive buffer.  
With suitable hardware, the transfer of data into the receiver memory  
may proceed concurrently with computations done after the receive was  
initiated and before it completed.  The use of nonblocking receives may also  
avoid system buffering and memory-to-memory copying, as information is provided  
early on the location of the receive buffer.  
<P> 
Nonblocking send start calls can use the same four modes as blocking sends:  
<em> standard</em>, <em> buffered</em>, <em> synchronous</em>, and  
<em> ready</em>.  
These carry the same meaning.Sends of all modes, <em> ready</em> excepted, can be started whether a matching  
receive has been started or not; a nonblocking <b> ready</b>  
send can be started only if  
the matching receive is already started.  In all cases, the send start call  
is <em> local</em>: it returns immediately, irrespective of the  
status of other <font face="sans-serif"> MPI</font> processes.  
If the call causes some system resource to be exhausted, then it will  
fail and return an error code.  High-quality  
implementations of <font face="sans-serif"> MPI</font> should ensure that this happens only  
in ``pathological'' cases.  That is, an <font face="sans-serif"> MPI</font> implementation  
should be able to support a  
large number of <em> pending</em> nonblocking operations.  
<P> 
The send-complete call returns no earlier than when all message data has been copied out of the send buffer.  
It may carry additional meaning, depending on the send mode.  
<P> 
If the send mode is <b> synchronous</b>,  
then the send-complete call is <em> nonlocal</em>;  
the send can complete only if a matching receive has been started  
and has been matched with the send.  
Note that a synchronous mode send may complete,  
if matched by a nonblocking receive,  
before the receive complete call occurs.  
(It can complete as soon as the sender ``knows'' the transfer will complete,  
but before the receiver ``knows'' the transfer will complete.)  
<P> 
If the send mode is <b> buffered</b>,  
then the send-complete call is <em> local</em>;  
the send must complete irrespective of the status of a matching receive.  
If there is no <em> pending</em>  
receive operation, then the message must be buffered.  
<P> 
If the send mode is <b> standard</b>,  
then the send-complete call can be either <em> local</em> or <em> nonlocal</em>.  
If the message is buffered, it is permitted for the send to complete  
before a matching receive is started.  
On the other hand, it is permitted for the send not to complete  
until a matching receive has been started  
and the message has been copied into the receive buffer.  
<P> 
Nonblocking sends can be matched with blocking receives, and  
vice-versa.  
<P> 
 
<br> 
<em> Advice to users.</em>  
<P> 
The completion of a send operation may be delayed for standard mode, and must  
be delayed for synchronous mode, until a matching receive has been started.  
The use of nonblocking sends in these two cases allows the sender to proceed  
ahead of the receiver, so that the computation is more tolerant  
of fluctuations in the speeds of the two <font face="sans-serif"> MPI</font> processes.  
<P> 
Nonblocking sends in the buffered and ready modes have a more limited  
impact, e.g., the blocking version of buffered send is capable of  
completing regardless of when a matching receive call is made. However,  
separating the start from the completion of these sends still gives  
some opportunity for optimization within the <font face="sans-serif"> MPI</font> library. For example,  
starting a buffered send gives an implementation more flexibility in  
determining if and how the message is buffered. There are also advantages  
for both nonblocking buffered and ready modes when data copying can  
be done concurrently with computation.  
<P> 
The message-passing model implies that communication is initiated by  
the sender.  
The communication will generally have lower overhead if a receive is  
already <em> started</em> when the sender initiates the communication (data can be moved  
directly to the receive buffer, and there is no need to queue a pending send  
request).  However,  
a receive operation can complete only after the matching send has <em> started</em>.  
The use of nonblocking receives allows one to achieve lower communication overheads  
without blocking the receiver while it waits for the send.  
 (<em> End of advice to users.</em>) <br> 
<ul> 
</ul> 

<P>
<hr>
<a href="node70.htm#Node70"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node53.htm#Node53"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node72.htm#Node72"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node53.htm#Node53"> Point-to-Point Communication</a>
<b>Next: </b><a href="node72.htm#Node72"> Communication Request Objects</a>
<b>Previous: </b><a href="node70.htm#Node70"> Model Implementation of Buffered Mode</a>
<p>
<HR>
Return to <A HREF="node601.htm">MPI-4.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-4.1 of November 2, 2023<BR>
HTML Generated on November 19, 2023
</FONT>
</body>
</html>
