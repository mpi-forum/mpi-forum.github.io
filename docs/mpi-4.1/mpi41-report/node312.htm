<!DOCTYPE html>
<html lang=en>
<head>
<!-- This file was generated by tohtml from chap-one-side/one-side-2-rendered -->
<!-- with the command
tohtml -default -numbers -dosnl -htables -quietlatex -allgif -endpage mpi4-forum-tail.htm -Wnoredef --mpidoc --latexpgm pdflatex --indexfile mpi41-report-html.idx -basedef mpi4defs.txt -o mpi41-report.tex mpi-report.tex 
-->
<title>Window of Dynamically Attached Memory</title>
</head>
<body style="background-color:#FFFFFF">
<hr><h2><span id="Node312">13.2.4. Window of Dynamically Attached Memory</span></h2>
<a href="node311.htm#Node311"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node308.htm#Node308"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node313.htm#Node313"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node308.htm#Node308"> Initialization</a>
<b>Next: </b><a href="node313.htm#Node313"> Window Destruction</a>
<b>Previous: </b><a href="node311.htm#Node311"> Window That Allocates Shared Memory</a>
<p>
  
  
<P> 
The previously described window creation procedures require the user to identify the local memory  
that may be a target of <font face="sans-serif"> RMA</font> calls at the time the window is created.    
This has advantages for both the  
programmer (only this memory can be updated by one-sided operations  
and provides greater safety) and the <font face="sans-serif"> MPI</font> implementation (special steps may  
be taken to make one-sided access to such memory more efficient).  
However, consider implementing a modifiable linked list using <font face="sans-serif"> RMA</font>  
operations; as new items are added to the list, memory must be  
allocated.  
In a C or C++ program,  
this memory is typically allocated using <tt>malloc</tt> or  
<tt>new</tt> respectively.  With the previously described window creation procedures, the programmer must create  
a window with a predefined amount of memory and then  
implement routines for allocating memory from within the window's  
memory.  In addition, there is no easy way to handle the situation  
where the predefined amount of memory turns out to be inadequate.  
To support this model, the routine <font face="sans-serif"> MPI_WIN_CREATE_DYNAMIC</font>  
creates a window that makes it possible to expose memory  
without remote synchronization. It must be used in combination with the local  
routines <font face="sans-serif"> MPI_WIN_ATTACH</font> and <font face="sans-serif"> MPI_WIN_DETACH</font>.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_WIN_CREATE_DYNAMIC(<span style="white-space:nowrap">info</span>, <span style="white-space:nowrap">comm</span>, <span style="white-space:nowrap">win</span>)</TD></TR>  
<TR><TD> IN info</TD><TD>info argument (handle)</TD></TR>  
<TR><TD> IN comm</TD><TD>intra-communicator (handle)</TD></TR>  
<TR><TD> OUT win</TD><TD>window object (handle)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Win_create_dynamic(MPI_Info info, MPI_Comm comm, MPI_Win *win) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Win_create_dynamic(info, comm, win, ierror) <br><br>TYPE(MPI_Info), INTENT(IN) :: <span style="white-space:nowrap">info</span> <br>TYPE(MPI_Comm), INTENT(IN) :: <span style="white-space:nowrap">comm</span> <br>TYPE(MPI_Win), INTENT(OUT) :: <span style="white-space:nowrap">win</span> <br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_WIN_CREATE_DYNAMIC(INFO, COMM, WIN, IERROR) <br><br>INTEGER <span style="white-space:nowrap">INFO</span>, <span style="white-space:nowrap">COMM</span>, <span style="white-space:nowrap">WIN</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
This procedure is collective over the group of  
<font face="sans-serif"> comm</font>. It returns a window <font face="sans-serif"> win</font> without memory attached.  
Existing <font face="sans-serif"> MPI</font> process memory can be attached as described below.  
This procedure returns a handle to a new window that can be used by <font face="sans-serif"> MPI</font> processes in the group of <font face="sans-serif"> comm</font>  
to perform <font face="sans-serif"> RMA</font> operations on attached memory.  
Because this window has special properties, it will sometimes be  
referred to as a <b> dynamic</b>  
window.  
<P> 
The <font face="sans-serif"> info</font> argument can be used to specify hints  
similar to the <font face="sans-serif"> info</font> argument for <font face="sans-serif"> MPI_WIN_CREATE</font>.    
<P> 
In the case of a window created with  
<font face="sans-serif"> MPI_WIN_CREATE_DYNAMIC</font>, the <font face="sans-serif"> target_disp</font> for all  
<font face="sans-serif"> RMA</font> functions is the address at the target; i.e., the effective  
<font face="sans-serif"> window_base</font> is <font face="sans-serif"> MPI_BOTTOM</font> and the <font face="sans-serif"> disp_unit</font> is one.  
For dynamic windows, the <font face="sans-serif"> target_disp</font>  
  argument to <font face="sans-serif"> RMA</font> communication operations is not restricted to  
  nonnegative values.  
Users  
should use <font face="sans-serif"> MPI_GET_ADDRESS</font> at the target process to  
determine the address of a target memory location and communicate this  
address to the origin process.    
<P> 
 
<br> 
<em> Advice to users.</em>  
<P> 
Users are cautioned that displacement arithmetic can overflow in  
variables of type <font face="sans-serif"> MPI_Aint</font> and result in unexpected values on some  
platforms.  
The <font face="sans-serif"> MPI_AINT_ADD</font> and <font face="sans-serif"> MPI_AINT_DIFF</font>  
functions can be used to safely perform address arithmetic with <font face="sans-serif"> MPI_Aint</font>  
displacements.  
 (<em> End of advice to users.</em>) <br> 
 
<br> 
<em> Advice  
        to implementors.</em>  
<P> 
In environments with heterogeneous data representations, care must be  
exercised in communicating addresses between <font face="sans-serif"> MPI</font> processes.  For example, it  
is possible that an address valid at the target <font face="sans-serif"> MPI</font> process (for example, a  
64-bit pointer) cannot be expressed as an address at the origin (for  
example, the origin uses 32-bit pointers).  For this reason, a portable  
<font face="sans-serif"> MPI</font> implementation should ensure that the type <font face="sans-serif"> MPI_AINT</font>  
(see Table <a href="node57.htm#Table4">4</a>) is able to store addresses  
from any <font face="sans-serif"> MPI</font> process.  
 (<em> End of advice to implementors.</em>) <br> 
Memory at the target cannot be accessed with this window until that memory  
has been  
attached using the function <font face="sans-serif"> MPI_WIN_ATTACH</font>.  
That is, in addition to using <font face="sans-serif"> MPI_WIN_CREATE_DYNAMIC</font> to  
create an <font face="sans-serif"> MPI</font> window, the user must use <font face="sans-serif"> MPI_WIN_ATTACH</font>  
before any local memory may be the target of an <font face="sans-serif"> MPI</font> <font face="sans-serif"> RMA</font> operation.  
Only memory that is currently accessible may be attached.    
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_WIN_ATTACH(<span style="white-space:nowrap">win</span>, <span style="white-space:nowrap">base</span>, <span style="white-space:nowrap">size</span>)</TD></TR>  
<TR><TD> IN win</TD><TD>window object (handle)</TD></TR>  
<TR><TD> IN base</TD><TD>initial address of memory to be attached (choice)</TD></TR>  
<TR><TD> IN size</TD><TD>size of memory to be attached in bytes (non-negative integer)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Win_attach(MPI_Win win, void *base, MPI_Aint size) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Win_attach(win, base, size, ierror) <br><br>TYPE(MPI_Win), INTENT(IN) :: <span style="white-space:nowrap">win</span> <br>TYPE(*), DIMENSION(..), ASYNCHRONOUS :: <span style="white-space:nowrap">base</span> <br>INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: <span style="white-space:nowrap">size</span> <br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_WIN_ATTACH(WIN, BASE, SIZE, IERROR) <br><br>INTEGER <span style="white-space:nowrap">WIN</span>, <span style="white-space:nowrap">IERROR</span> <br>&lt;type&gt; <span style="white-space:nowrap">BASE(*)</span> <br>INTEGER(KIND=MPI_ADDRESS_KIND) <span style="white-space:nowrap">SIZE</span> <br></tt>  
<P> 
Attaches a local memory region beginning at  
<font face="sans-serif"> base</font> for remote access within the given window. The memory region  
specified must not contain any part that is already attached to the  
window <font face="sans-serif"> win</font>,  
that is, attaching overlapping memory concurrently within the same window is  
erroneous. The argument <font face="sans-serif"> win</font> must be a window that was created with  
<font face="sans-serif"> MPI_WIN_CREATE_DYNAMIC</font>.  
The local memory region attached to the window consists of <font face="sans-serif"> size</font> bytes,  
starting at address <font face="sans-serif"> base</font>.  
In C, <font face="sans-serif"> base</font> is the starting address of a  
memory region. In Fortran, one can pass the first element of a memory  
region or a whole array, which must be `simply contiguous' (for  
`simply contiguous,' see Section <a href="node479.htm#Node479">Problems Due to Data Copying and Sequence Association with Subscript Triplets</a>).  
Multiple (but nonoverlapping) memory  
regions may be attached to the same window.  
<P> 
 
<br> 
<em> Rationale.</em>  
<P> 
Requiring that memory be explicitly attached before it is exposed to  
one-sided access by other <font face="sans-serif"> MPI</font> processes can  
simplify  
implementations and improve performance. The ability to make memory  
available for <font face="sans-serif"> RMA</font> operations without requiring a collective  
<font face="sans-serif"> MPI_WIN_CREATE</font> call is needed for some one-sided programming  
models.  
 (<em> End of rationale.</em>) <br> 
 
<br> 
<em> Advice to users.</em>  
<P> 
Attaching memory to a window may require the use of scarce resources; thus,  
attaching large regions of memory is not recommended in portable  
programs.  Attaching memory to a window may fail if sufficient resources are  
not available; this is similar to the behavior of  
<font face="sans-serif"> MPI_ALLOC_MEM</font>.  
<P> 
The user is also responsible for ensuring that <font face="sans-serif"> MPI_WIN_ATTACH</font> at  
the target has returned before an <font face="sans-serif"> MPI</font> process attempts to target that  
memory with an <font face="sans-serif"> MPI</font> <font face="sans-serif"> RMA</font> operation.  
<P> 
Performing an <font face="sans-serif"> RMA</font> operation on memory that has not been attached to  
a window created with <font face="sans-serif"> MPI_WIN_CREATE_DYNAMIC</font> is  
erroneous. (<em> End of advice to users.</em>) <br> 
 
<br> 
<em> Advice  
        to implementors.</em>  
<P> 
A high-quality implementation will attempt to make as much memory  
available for attaching as possible. Any limitations should be  
documented by the implementor.  
 (<em> End of advice to implementors.</em>) <br> 
<font face="sans-serif"> MPI_WIN_ATTACH</font> is a local procedure that is not collective.  
Memory may be detached with the procedure  
<font face="sans-serif"> MPI_WIN_DETACH</font>. After memory has been  
detached, it may not be the target of an <font face="sans-serif"> MPI</font> <font face="sans-serif"> RMA</font> operation on   
that window (unless the   
memory is re-attached with <font face="sans-serif"> MPI_WIN_ATTACH</font>).  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_WIN_DETACH(<span style="white-space:nowrap">win</span>, <span style="white-space:nowrap">base</span>)</TD></TR>  
<TR><TD> IN win</TD><TD>window object (handle)</TD></TR>  
<TR><TD> IN base</TD><TD>initial address of memory to be detached (choice)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Win_detach(MPI_Win win, const void *base) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Win_detach(win, base, ierror) <br><br>TYPE(MPI_Win), INTENT(IN) :: <span style="white-space:nowrap">win</span> <br>TYPE(*), DIMENSION(..), ASYNCHRONOUS :: <span style="white-space:nowrap">base</span> <br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_WIN_DETACH(WIN, BASE, IERROR) <br><br>INTEGER <span style="white-space:nowrap">WIN</span>, <span style="white-space:nowrap">IERROR</span> <br>&lt;type&gt; <span style="white-space:nowrap">BASE(*)</span> <br></tt>  
<P> 
Detaches a previously attached memory region beginning at  
<font face="sans-serif"> base</font>. The arguments <font face="sans-serif"> base</font> and <font face="sans-serif"> win</font>  
must match the arguments passed to a previous call to  
<font face="sans-serif"> MPI_WIN_ATTACH</font>.  
<font face="sans-serif"> MPI_WIN_DETACH</font> is a local procedure that is not collective.  
<P> 
 
<br> 
<em> Advice to users.</em>  
<P> 
Detaching memory may permit the implementation to make more  
efficient use of special memory or provide memory that may be needed  
by a subsequent <font face="sans-serif"> MPI_WIN_ATTACH</font>.  Users are encouraged to  
detach memory that is no longer needed.  
Memory should be detached before it is freed by the user.  
 (<em> End of advice to users.</em>) <br> 
Memory becomes detached when the associated dynamic memory window is  
freed, see Section <a href="node313.htm#Node313">Window Destruction</a>.  
<P> 

<P>
<hr>
<a href="node311.htm#Node311"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node308.htm#Node308"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node313.htm#Node313"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node308.htm#Node308"> Initialization</a>
<b>Next: </b><a href="node313.htm#Node313"> Window Destruction</a>
<b>Previous: </b><a href="node311.htm#Node311"> Window That Allocates Shared Memory</a>
<p>
<HR>
Return to <A HREF="node601.htm">MPI-4.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-4.1 of November 2, 2023<BR>
HTML Generated on November 19, 2023
</FONT>
</body>
</html>
