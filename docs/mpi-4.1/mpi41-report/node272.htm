<!DOCTYPE html>
<html lang=en>
<head>
<!-- This file was generated by tohtml from chap-dynamic/dynamic-2-rendered -->
<!-- with the command
tohtml -default -numbers -dosnl -htables -quietlatex -allgif -endpage mpi4-forum-tail.htm -Wnoredef --mpidoc --latexpgm pdflatex --indexfile mpi41-report-html.idx -basedef mpi4defs.txt -o mpi41-report.tex mpi-report.tex 
-->
<title>Session Creation and Destruction Methods</title>
</head>
<body style="background-color:#FFFFFF">
<hr><h2><span id="Node272">12.3.1. Session Creation and Destruction Methods</span></h2>
<a href="node271.htm#Node271"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node271.htm#Node271"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node273.htm#Node273"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node271.htm#Node271"> The Sessions Model</a>
<b>Next: </b><a href="node273.htm#Node273"> Processes Sets</a>
<b>Previous: </b><a href="node271.htm#Node271"> The Sessions Model</a>
<p>
  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_SESSION_INIT(<span style="white-space:nowrap">info</span>, <span style="white-space:nowrap">errhandler</span>, <span style="white-space:nowrap">session</span>)</TD></TR>  
<TR><TD> IN info</TD><TD>info object to specify thread support level and <font face="sans-serif"> MPI</font> implementation specific resources (handle)</TD></TR>  
<TR><TD> IN errhandler</TD><TD>error handler to invoke in the event that an error is encountered during this function call (handle)</TD></TR>  
<TR><TD> OUT session</TD><TD>new session (handle)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Session_init(MPI_Info info, MPI_Errhandler errhandler, MPI_Session *session) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Session_init(info, errhandler, session, ierror) <br><br>TYPE(MPI_Info), INTENT(IN) :: <span style="white-space:nowrap">info</span> <br>TYPE(MPI_Errhandler), INTENT(IN) :: <span style="white-space:nowrap">errhandler</span> <br>TYPE(MPI_Session), INTENT(OUT) :: <span style="white-space:nowrap">session</span> <br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_SESSION_INIT(INFO, ERRHANDLER, SESSION, IERROR) <br><br>INTEGER <span style="white-space:nowrap">INFO</span>, <span style="white-space:nowrap">ERRHANDLER</span>, <span style="white-space:nowrap">SESSION</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
The <font face="sans-serif"> info</font> argument is used to request <font face="sans-serif"> MPI</font> functionality requirements and possible <font face="sans-serif"> MPI</font> implementation specific capabilities.  The following info keys are predefined:  
<P> 
<dl> 
 
<dt> 
<b></b><font face="sans-serif"> thread_level</font></b><dd> 
 used to request the thread support level required for <font face="sans-serif"> MPI</font> objects  
derived from the Session.  Allowed values are <font face="sans-serif"> MPI_THREAD_SINGLE</font>, <font face="sans-serif"> MPI_THREAD_FUNNELED</font>, <font face="sans-serif"> MPI_THREAD_SERIALIZED</font>, and <font face="sans-serif"> MPI_THREAD_MULTIPLE</font>.  Note that the thread support value is specified by a string rather than the integer  
values supplied to <font face="sans-serif"> MPI_INIT_THREAD</font>.  The thread support level actually provided by the <font face="sans-serif"> MPI</font> implementation  
can be determined via a subsequent call to <font face="sans-serif"> MPI_SESSION_GET_INFO</font> to return the info object associated with  
the Session.  The default thread support level is <font face="sans-serif"> MPI</font> implementation dependent.  
 
<dt> 
<b></b><font face="sans-serif"> mpi_memory_alloc_kinds</font></b><dd> 
  
used to request support for memory allocation kinds to be used by the calling <font face="sans-serif"> MPI</font> process on <font face="sans-serif"> MPI</font> objects derived from the Session.  
See Section <a href="node279.htm#Node279">Memory Allocation Info</a>.  
A value for this info key can also be supplied as an argument to an <font face="sans-serif"> MPI</font> startup mechanism as described in Section <a href="node280.htm#Node280">Portable <font face="sans-serif"> MPI</font> Process Startup</a>.  
</dl> 
<br> 
The <font face="sans-serif"> errhandler</font> argument specifies an error handler to invoke in the event that the  
Session instantiation call encounters an error.  
The error handler shall be either a pre-defined error handler (see <a href="node252.htm#Node252">Error Handling</a>)  
or one created using <font face="sans-serif"> MPI_SESSION_CREATE_ERRHANDLER</font>.  
Session instantiation is intended to be a lightweight operation.  
An <font face="sans-serif"> MPI</font> process may instantiate multiple Sessions. <font face="sans-serif"> MPI_SESSION_INIT</font> is always thread safe; multiple threads  
within an application may invoke it concurrently.  
<P> 
 
<br> 
<em> Advice to users.</em>  
<P> 
Requesting ``<font face="sans-serif"> MPI_THREAD_SINGLE</font>'' thread support level is generally not recommended, because this will conflict with other components of an application requesting higher levels of thread support.  
 (<em> End of advice to users.</em>) <br> 
 
<br> 
<em> Advice  
        to implementors.</em>  
<P> 
Owing to the restrictions of the <font face="sans-serif"> MPI_THREAD_SINGLE</font> thread support level, implementators are discouraged from making this the default thread support level for Sessions.  
 (<em> End of advice to implementors.</em>) <br> 
<TABLE><TR><TD COLSPAN=2>MPI_SESSION_FINALIZE(<span style="white-space:nowrap">session</span>)</TD></TR>  
<TR><TD> INOUT session</TD><TD>session to be finalized (handle)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Session_finalize(MPI_Session *session) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Session_finalize(session, ierror) <br><br>TYPE(MPI_Session), INTENT(INOUT) :: <span style="white-space:nowrap">session</span> <br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_SESSION_FINALIZE(SESSION, IERROR) <br><br>INTEGER <span style="white-space:nowrap">SESSION</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
  
This routine cleans up all <font face="sans-serif"> MPI</font> state associated with the supplied <font face="sans-serif"> session</font>.  
Every instantiated Session must be finalized using <font face="sans-serif"> MPI_SESSION_FINALIZE</font>.  
The handle <font face="sans-serif"> session</font> is set to <font face="sans-serif"> MPI_SESSION_NULL</font> by the call.  
<P> 
Before an <font face="sans-serif"> MPI</font> process invokes <font face="sans-serif"> MPI_SESSION_FINALIZE</font>, the process must  
perform all <font face="sans-serif"> MPI</font> calls needed to complete its  
involvement in <font face="sans-serif"> MPI</font> communications: it must locally complete all  
<font face="sans-serif"> MPI</font> operations that it initiated and it must execute matching calls needed to complete <font face="sans-serif"> MPI</font>  
communications initiated by other processes.  
This means that before calling <font face="sans-serif"> MPI_SESSION_FINALIZE</font>, all message handles associated  
with this session must be received  
(with <font face="sans-serif"> MPI_MRECV</font> or derived procedures)  
and all request handles associated with this session must be freed  
in the case of nonblocking operations,  
and must be inactive or freed in the case of persistent operations  
(i.e., by calling one of the procedures  
<font face="sans-serif"> MPI_{TEST<i>|</i>WAIT}{<i>|</i>ANY<i>|</i>SOME<i>|</i>ALL}</font>  
or <font face="sans-serif"> MPI_REQUEST_FREE</font>).  
<P> 
The call to <font face="sans-serif"> MPI_SESSION_FINALIZE</font> does not free objects created by  
<font face="sans-serif"> MPI</font> calls; these objects are freed using  
<font face="sans-serif"> MPI_</font><font face="sans-serif"> XXX</font>_FREE</font>,  
<font face="sans-serif"> MPI_COMM_DISCONNECT</font>, or  
<font face="sans-serif"> MPI_FILE_CLOSE</font> calls.  
<P> 
Once <font face="sans-serif"> MPI_SESSION_FINALIZE</font> returns, no <font face="sans-serif"> MPI</font> procedure may be called in the Sessions Model that are related to this session  
(not even freeing objects that are derived from this session),  
except for those listed in Section <a href="node277.htm#Node277"><font face="sans-serif"> MPI</font> Functionality that is Always Available</a>.  
<P> 
 
<br> 
<em> Advice to users.</em>  
<P> 
Opaque objects and their handles may bind internal resources.  
Therefore, it is highly recommended to explicitly free the handles associated with this session before finalizing it.  
Such associated handles can be group, communicator, window, file, message, and request handles,  
whereas datatype, operation (e.g., for reductions), error handler, and info handles exist independently  
of the World Model or a session in the Sessions Model.  
In addition, if attributes are cached on such an opaque object (see Section <a href="node204.htm#Node204">Caching</a>),  
then the delete callback functions are only invoked when the object is explicitly freed (or disconnected).  
 (<em> End of advice to users.</em>) <br> 
Most handles that exist independently from the World Model or a session in the Sessions Model, e.g., datatype handles,  
can be created only while <font face="sans-serif"> MPI</font> is initialized.  
For example, a datatype handle that was created when one particular session existed  
can be used in any other session (or in the World Model), even if the second session  
was initialized after the first session had already been finalized  
and no other session existed in between.  
See Section <a href="node277.htm#Node277"><font face="sans-serif"> MPI</font> Functionality that is Always Available</a> for handle creation procedures that do not require that <font face="sans-serif"> MPI</font> is initialized.  
<P> 
<font face="sans-serif"> MPI_SESSION_FINALIZE</font> may be synchronizing on any or all of the groups associated with  
communicators, windows, or files derived from the session and not disconnected, freed, or closed,  
respectively, before the call to the <font face="sans-serif"> MPI_SESSION_FINALIZE</font> procedure.  
<font face="sans-serif"> MPI_SESSION_FINALIZE</font> behaves as if all such synchronizations occur concurrently.  
As <font face="sans-serif"> MPI_COMM_FREE</font> may mark a communicator for freeing later,  
<font face="sans-serif"> MPI_SESSION_FINALIZE</font> may be synchronizing on the group associated  
with a communicator that is only freed (with <font face="sans-serif"> MPI_COMM_FREE</font>)  
rather than disconnected (with <font face="sans-serif"> MPI_COMM_DISCONNECT</font>).  
<P> 
 
<br> 
<em> Rationale.</em>  
<P> 
This rule is similar to the rule that <font face="sans-serif"> MPI_FINALIZE</font> is collective (see <a href="node268.htm#Node268">Finalizing <font face="sans-serif"> MPI</font></a>),  
but does not require that <font face="sans-serif"> MPI_SESSION_FINALIZE</font> be collective over all connected <font face="sans-serif"> MPI</font> processes.  
It also allows for cases where some <font face="sans-serif"> MPI</font> processes may have derived a set of communicators  
using a different number of session handles.  See Example <a href="node272.htm#Node272">Session Creation and Destruction Methods</a>.  
 (<em> End of rationale.</em>) <br> 
 
<br> 
<em> Advice  
        to implementors.</em>  
<P> 
This rule also allows for the completion of communications the <font face="sans-serif"> MPI</font> process is involved with  
that may not yet be completed from the viewpoint of the underlying <font face="sans-serif"> MPI</font> system.  
See Section <a href="node48.htm#Node48">Progress</a> on <em> progress</em>  
and the advice to implementors at the end of Section <a href="node268.htm#Node268">Finalizing <font face="sans-serif"> MPI</font></a>.  
 (<em> End of advice to implementors.</em>) <br> 
 
<br> 
<em> Advice  
        to implementors.</em>  
<P> 
An <font face="sans-serif"> MPI</font> implementation should be able to implement the semantics of <font face="sans-serif"> MPI_SESSION_FINALIZE</font>  
as a <em> local</em> procedure,  
provided an application frees all <font face="sans-serif"> MPI</font> windows, closes all <font face="sans-serif"> MPI</font> files,  
and uses <font face="sans-serif"> MPI_COMM_DISCONNECT</font> to free all <font face="sans-serif"> MPI</font> communicators  
associated with a session  
prior to invoking <font face="sans-serif"> MPI_SESSION_FINALIZE</font> on the corresponding session handle.  
 (<em> End of advice to implementors.</em>) <br> 
<br><b> Example</b>  
  
  
Three <font face="sans-serif"> MPI</font> processes are connected with 2 communicators (indicated by the <tt>=</tt> symbols),  
derived from one session handle in process X but from two separate session handles  
in both process Y and Z.  
<br> 
<pre><tt>  process-X     process-Y     process-Z     Remarks 
                                            sesX, sesYA, ses YB, sesZA and 
                                              sesZB are session handles. 
    (sesX)=======(sesYA)=======(sesZA)      communicator_1 and 
    (sesX)=======(sesYB)=======(sesZB)      communicator_2 are derived 
                                              from them. 
   SF(sesX)     SF(sesYA)     SF(sesZA)     SF = MPI_SESSION_FINALIZE 
                SF(sesYB)     SF(sesZB) 
</tt></pre> 
Process X has only to finalize its one session handle,  
whereas the other two <font face="sans-serif"> MPI</font> processes have to call  
<font face="sans-serif"> MPI_SESSION_FINALIZE</font> twice in the same sequence with respect to  
the communicators derived from the session handles.  
Specifically, both process Y and process Z shall call <font face="sans-serif"> MPI_SESSION_FINALIZE</font>  
for the session from which <tt>communicator_1</tt> was derived before calling the  
<font face="sans-serif"> MPI_SESSION_FINALIZE</font> for the session from which <tt>communicator_2</tt> was derived,  
or vice versa (i.e., both shall finalize the session for <tt>communicator_2</tt>  
first then finalize the session for <tt>communicator_1</tt>).  
The call <tt>SF(ses)</tt> in process X may not return until  
both <tt>SF(ses*A)</tt> and <tt>SF(ses*B)</tt> are called in processes Y and Z.  
  
<P> 

<P>
<hr>
<a href="node271.htm#Node271"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node271.htm#Node271"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node273.htm#Node273"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node271.htm#Node271"> The Sessions Model</a>
<b>Next: </b><a href="node273.htm#Node273"> Processes Sets</a>
<b>Previous: </b><a href="node271.htm#Node271"> The Sessions Model</a>
<p>
<HR>
Return to <A HREF="node601.htm">MPI-4.1 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-4.1 of November 2, 2023<BR>
HTML Generated on November 19, 2023
</FONT>
</body>
</html>
